Mina: Decentralized Cryptocurrency at Scale

Joseph Bonneau1, Izaak Meckler2, Vanishree Rao2, and Evan
Shapiro2

1New York University
2O(1) Labs

March 2020

Abstract

We introduce the notion of a succinct blockchain, a replicated state
machine in which each state transition (block) can be eï¬ƒciently veri-
ï¬ed in constant time regardless of the number of prior transitions in the
system. Traditional blockchains require veriï¬cation time linear in the
number of transitions. We show how to construct a succinct blockchain
using recursively composed succinct non-interactive arguments of knowl-
edge (SNARKs). Finally, we instantiate this construction to implement
Mina, a payment system (cryptocurrency) using a succinct blockchain.
Mina oï¬€ers payment functionality similar to Bitcoin, with a dramatically
faster veriï¬cation time of 200ms making it practical for lightweight clients
and mobile devices to perform full veriï¬cation of the systemâ€™s history.

1

Introduction

Bitcoin and other distributed payment systems (also called cryptocurrencies or
simply blockchains) aim to provide a decentralized system for making and ver-
ifying payments. However, for traditional cryptocurrencies, including Bitcoin,
decentralization comes at the cost of scalability as each node needs to process
the entire system history upon joining the network. Asymptotically, verifying
a blockchain containing ğ‘¡ transactions requires ğ›º(ğ‘¡) time (usually more than
linear in ğ‘¡ as bookkeeping is required to resolve transaction references during
veriï¬cation). At the time of this writing, Bitcoinâ€™s blockchain is over 250 GB
and contains over 500 M transactions (see Figure 1). Downloading and verifying
this history takes days on a typical laptop.

These resource requirements deter most users from running a full node that
stores and veriï¬es the blockchain. As seen in Figure 2, the number of full nodes
in Bitcoin is not growing despite its increasing popularity over time. Instead
most users run a light node, verifying only block headers but not transactions,
or an ultralight node verifying nothing and relying on trusted advice from a

1

trusted server. This undermines decentralization as most clients rely on trust
rather than independent veriï¬cation. It also undermines performance: block size
(and therefore transaction throughput) is artiï¬cially capped in part to mitigate
the burden of veriï¬cation.

Figure 1: Growth of the Bitcoin blockchain over time, in GB. Source: www.
blockchain.com.

2

Figure 2: Estimated number of full nodes participating in the Bitcoin and
Ethereum networks over time. Source: www.bitnodes.earn.com and www.
Ethernodes.org.

In this work, our goal is to design a decentralized payment system that
oï¬€ers eï¬ƒcient veriï¬cation of system history from genesis without relying on
any external advice. Speciï¬cally, we aim to provide veriï¬cation time constant
(ğ‘‚ (1)) in the number of transactions; we call such a blockchain, a succinct
blockchain.

We achieve this goal by including succinct proofs of state validity in each
block. Generically, it is possible to compute a succinct non-interactive argument
of knowledge (a SNARK) of any NP statement, including for example that
the system stated committed to by the current block in a blockchain can be
reached from a the genesis state by a series of valid transactions in the system.
This (large) list of transactions is a witness that the current block is valid.
However, computing a new proof of validity of the entire system history for
each block would be prohibitively expensive.
Instead, we employ techniques
from incrementally computable SNARKs to ensure that the cost of computing
a proof for each block is proportional only to the number of transactions added
since the previous block.

We instantiate the notion of a succinct blockchain and introduce the Mina
protocol. Mina is a payment-oriented blockchain oï¬€ering similar functionality
to Bitcoin, although with diï¬€erent transaction semantics. In particular, Mina
uses an account-based model (as in Ethereum [24]) (instead of the UTXO model
as in Bitcoin[18] and others [19]), wherein the current state of the blockchain is
a list of all account balances rather than a list of unspent coins (UTXOs).

3

Each block contains a commitment to this state (in a Merkle tree) and not
the entire state. Therefore a full node need not store the entire state, but can
verify account balances eï¬ƒciently given only the state commitment in the latest
block header. However, a prover in our system (roughly equivalent to a miner
in Bitcoin) does needs to store the full state since it is part of the witness when
proving the validity of new blocks.

For the consensus protocol of Mina, we present the ï¬rst provably-secure
proof-of-stake (PoS) consensus protocol for succinct blockchains called Ouroboros
Samasika. Note that an oï¬€-the-shelf consensus mechanism is not necessarily
compatible with a succinct blockchain framework, since the way consensus is
achieved when there are multiple contending chains could relying on arbitrary
transaction history, forcing nodes to store the entire transaction history.
In
fact, this is a natural approach for consensus mechanisms, since the information
needed to tell apart an honest chain from a dishonest one is likely to involve
details at the point of the fork; since it is possible for a party to learn about a
fork long after it occurred, it may need to store the entire history to assist in
the chain selection process. This is indeed the case in the known PoS consensus
mechanisms [16, 12, 3]. Furthermore, other PoS consensus mechanisms rely on
a trusted external advice for bootstrapping [11].

Concretely, in our current implementation, a state proof size is just 864 bytes
and it takes around 200ms to verify it. Thus, any device that can support this
level of computation, such as the current smartphones, can verify the current
state of the system with no trusted advice.

Beyond incrementally computable SNARKs, we employ multiple optimiza-
tions, the most signiï¬cant of which is parallel scan state. At a high level, this
improves transaction throughput beyond the limits of sequentially computed
proofs. Roughly, the idea is to enqueue all the blocks that still need to be ab-
sorbed into a proof and distribute their proving across parallel provers. We also
introduce a special queue of recent transactions to reduce transaction conï¬rma-
tion latency below the limits imposed by minimum proving times. Furthermore,
we introduce a special incentive structure to maximizing prover participation in
the network.

1.1 Our Contributions

In summary, our contributions are:

â€¢ We formalize the notion of a succinct blockchain. This notion may be of
independent interest for alternative constructions of succinct blockchains.

â€¢ We present an approach to constructing a succinct blockchain for generic
functionalities modeled as replicated state machines using incrementally-
computable SNARKs.

â€¢ We present a concrete implementation of our approach for the speciï¬c

functionality of a payments system called Mina.

4

â€¢ We present Ouroboros Samasika, a provably-secure PoS consensus proto-

col that is adaptively secure and oï¬€ers bootstrapping from genesis.

â€¢ We introduce the notion of a parallel scan state to improve transaction
conï¬rmation time beyond the limits otherwise imposed by the proof con-
struction.

â€¢ We present a performance evaluation report of executing the protocol

involving a public community.

2 Succinct Blockchains

In this section, we introduce the notion of succinct blockchains.

Underlying concepts of a blockchain. We begin by recalling deï¬nitions
of certain underlying concepts of a blockchain [12]. This will assist in deï¬ning
succinct blockchains.

Deï¬nition 2.1 (State, Block Proof, Block Producer, Block, Blockchain, Genesis
Block). A state is a string st âˆˆ {0, 1}ğœ†. A block proof is a value (or a set of
values) ğœ‹ğµ
ğ‘– containing information to verify whether the block is valid. Each
block is associated with a unique party called its block producer. A block ğµğ‘– =
(snğ‘–, stğ‘–, ğœ‹ğµ
ğ‘– , ğ‘‘ğ‘–, b-pkğ‘–, ğ‘-sigğ‘–) generated with a serial number snğ‘– âˆˆ N contains the
current state stğ‘–, a block proof ğœ‹ğµ
ğ‘– , data ğ‘‘ğ‘– âˆˆ {0, 1}âˆ—, the block producerâ€™s public
key b-pkğ‘– and a signature ğ‘-sigğ‘– on (snğ‘–, stğ‘–, ğœ‹ğµ

ğ‘– , ğ‘‘ğ‘–) with respect to b-pkğ‘–.

A blockchain is a sequence of blocks C = (ğµ1, . . . , ğµğ‘›) associated with a
strictly increasing sequence of serial numbers. The ï¬rst block ğµ1 is called the
genesis block. The length len(C) = ğ‘› of a blockchain is the number of blocks in
it.

Succinct blockchains. We are now ready to introduce the deï¬nition of a
succinct blockchain protocol. The deï¬nition will also introduce the notion of a
blockchain summary, which, at a high level, is some summary of a blockchain
such that the summary is valid if and only if the blockchain is valid. The concept
of a blockchain underlying a blockchain summary will not be evident from the
deï¬nition of a succinct blockchain protocol itself. However, it will be captured
via the notion of chain extractability in Deï¬nition 2.4.

Deï¬nition 2.2 (Succinct Blockchain Protocol). A succinct blockchain pro-
tocol ğ›± is characterized by a tuple of ï¬ve PPT algorithms (VerifyConsensus,
UpdateConsensus, VerifyBlock, UpdateChain, VerifyChain) syntactically deï¬ned
as follows.

â€¢ VerifyConsensus(consensusState, consensusProof) â†’ (cid:62)/âŠ¥ : This algo-
rithm takes as input a consensusState and a consensusProof, veriï¬es ac-
cording to some notion of correctness and outputs (cid:62) or âŠ¥, respectively.

5

â€¢ UpdateConsensus(consensusState, consensusProof) â†’ nextConsensusState :
This algorithm also takes as input a consensusState and a consensusProof
and outputs an updated consensus state.

â€¢ VerifyChainSummary(Sğ‘–) â†’ (cid:62)/âŠ¥ : This algorithms veriï¬es whether a

given blockchain summary Sğ‘– is valid or not.

â€¢ VerifyBlock(Sğ‘–âˆ’1, ğµğ‘–) â†’ (cid:62)/âŠ¥ : This algorithms veriï¬es whether a given
block ğµğ‘– is valid with respect to a given blockchain summary Sğ‘–âˆ’1. As a
part of the veriï¬cation, it checks that VerifyConsensus(consensusStateğ‘–âˆ’1,
consensusProof ğ‘– â†’ (cid:62), where, Sğ‘–âˆ’1 contains consensusStateğ‘–âˆ’1 and ğœ‹ğµ
ğ‘–
contains consensusProof ğ‘–, where, ğµğ‘– = (Â·, Â·, ğœ‹ğµ

ğ‘– , Â·, Â·, Â·).

â€¢ UpdateChainSummary(Sğ‘–âˆ’1, ğµğ‘–) â†’ Sğ‘– : This algorithm takes a blockchain
summary Sğ‘–âˆ’1 and a new block ğµğ‘– and outputs an updated blockchain
summary Sğ‘–.

The protocol satisï¬es the following succinctness property.

Succinctness. Each of the algorithms VerifyBlock, VerifyChainSummary, and

VerifyConsensus runs in time poly(ğœ†). Furthermore, the size of the blockchain
summary Sğ‘– at any time ğ‘¡ğ‘– is of size poly(ğœ†) (i.e., constant in the number
of chain summary updates).

Remark 2.1 (Consensus mechanism). The algorithm pair (VerifyConsensus,
UpdateConsensus) is said to constitute a consensus mechanism. The following
are some examples of how the notion can be instantiated. For proof-of-work
protocols (e.g. Bitcoin), the consensus state would contain several previous
diï¬ƒculty targets and block times (from which to compute the current diï¬ƒculty
target) and a consensus proof would contain the proof-of-work itself along with
a new time to update the state with. For an Ouroboros Praos-style [12] proof-of-
stake mechanism, the consensus state would contain the current random seed,
the (Merkle root of) the current epochâ€™s stakes, and some information about the
previous blocks and block times. A consensus proof would contain a public-key
and a veriï¬able random function (VRF) evaluation proof meeting the threshold
target corresponding to that public-key and the stakes indicated in the consensus
state.

Types of Roles. Per the above deï¬nition, there are three kinds of roles in a
succinct blockchain. (There can be additional roles depending on the instanti-
ation.)

1. Full node: In this role, a party keeps track of the blockchain summary

and veriï¬es it.

2. Block producer: In this role, a party produces a block.

3. Blockchain summary producer: In this role, a party generates blockchain

summaries.

6

Note that the signiï¬cant advantage of a succinct blockchain is that any party
with reasonable resources can be a full node, due to the succinctness property.
That is, a succinct blockchain does not require the role of light clients to cope
with growing blockchain sizes.

Relationship between blockchain summary and underlying blockchain.
Having deï¬ned a succinct blockchain in terms of blockchain summaries, we will
now show how the summaries are related to the underlying blockchains. Roughly
speaking, we would like that the blockchain summaries inherit validity of un-
derlying blockchains. That is, a summary is valid if and only if the underlying
blockchain is valid.

Furthermore, given a blockchain summary, we arrive at its underlying
blockchain through the notion of extractability. Speciï¬cally, we deï¬ne extrac-
tion recursively; that is, given a blockchain summary with serial number ğ‘–, an
extractor (using some additional information) extracts a blockchain summary
with serial number ğ‘– âˆ’ 1 and a block ğµğ‘–, wherein all the components satisfy the
necessary veriï¬cation tests. The additional information the extractor uses is the
execution transcript which we call the execution trace formally deï¬ned below.

Deï¬nition 2.3 (Execution Trace, Blockchain Summary in an Execution Trace).
For an (adaptive) adversary A and an environment Z, an execution trace E
of a blockchain protocol ğ›± by a set of parties U with security parameter ğœ†
is a transcript including the inputs provided by Z, the random coins of the
parties and the random coins of the adversary. This data determines the entire
dynamics of the protocol: messages sent and delivered, the internal states of the
parties at each step and the set of corrupt parties at each step. We denote the
trace by E â† ğ›± (1ğœ†, U) or simply E â† ğ›± (U).

For every blockchain protocol ğ›± , there exists an algorithm CurrChain, such
that for every set of PPT parties U, E â† ğ›± (U), time ğ‘¡, honest party ğ‘ƒ âˆˆ U, we
have that CurrChain outputs a valid blockchain summary; i.e., CurrChain(E, ğ‘ƒ, ğ‘¡)
â†’ S and VerifyChainSummary(S) â†’ (cid:62). S is said to be the blockchain sum-
mary in ğ‘ƒâ€™s view of E at time ğ‘¡. A blockchain summary in an execution trace E
is a blockchain summary C in any honest partyâ€™s view at any time ğ‘¡; we denote
this by S âˆˆ E.

We will now deï¬ne the notion of chain extractability. This deï¬nition utilizes
a notion of â€˜serial number of a blockchain summaryâ€™.
Intuitively, it is just
a natural number ğ‘— that represents the number of blocks in the underlying
blockchain. It is indicated in the subscript as S ğ‘— .

Deï¬nition 2.4 (Chain Extractability). A succinct blockchain protocol ğ›± =
(VerifyConsensus, UpdateConsensus, VerifyBlock, UpdateChain, VerifyChain) is
said to satisfy chain extractability if the following probability Advğ›± , U (1ğœ†) is
negligibly close to 1 for every U = {Ağ‘– }ğ‘–, a set of PPT algorithms. For every
Ağ‘–, there exists a PPT algorithm ExtAğ‘– , called an extractor, and Advğ›± , U is
deï¬ned as follows.

7

Advğ›± ,U (1ğœ†) := Pr

ï£®
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£°
where, ğ‘Ÿ is the random coins of Ağ‘–.

VerifyChainSummary(S ğ‘—âˆ’1) = (cid:62)
âˆ§
VerifyBlock(S ğ‘—âˆ’1, ğµ ğ‘— ) = (cid:62)
âˆ§
ğµ1 is a Genesis block
âˆ§
S0 is an empty string

:

E â† ğ›± (U)
âˆ€S ğ‘— âˆˆ E, âˆƒAğ‘– âˆˆ U
(S ğ‘—âˆ’1, ğµ ğ‘— ) â† ExtAğ‘– (E, S ğ‘— , ğ‘Ÿ)

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

Deï¬nition 2.5 (Blockchain underlying a Blockchain Summary). Let ğ›± be a
blockchain protocol which satisï¬es chain extractability. Let E be an execution
of the protocol by a set of parties U. Let ğ‘ƒ âˆˆ U be an honest party that has
been active since the beginning of the protocol. Let Sâ„“ be the blockchain in
E (cid:48). For every 1 â‰¤ ğ‘– â‰¤ â„“, let ğµğ‘– be a block guaranteed by the property of chain
extractability. The sequence (ğµ1, . . . , ğµâ„“) is called the blockchain underlying Sâ„“.

2.1 Security Properties of a Succinct Blockchain

We will now enlist the security properties of a succinct blockchain. Rather than
the blockchain summaries, the properties pertain to the underlying blockchain
guaranteed by the chain extractability property.

Consider a blockchain protocol ğ›± and an execution E. Let C be the un-
derlying blockchain of the blockchain summary S in E. We recall the following
properties that were ï¬rst rigorously formulated in [14]. We will assume that
time is divided into predeï¬ned slots.

Common Preï¬x (CP); with parameters ğ‘˜ âˆˆ N. The blockchains C1, C2 cor-
responding to two alert parties at the onset of the slots sl1 â‰¤ sl2 are such
(cid:100)ğ‘˜ denotes the blockchain obtained by removing
that C1
the last ğ‘˜ blocks from C1 and (cid:52) denotes the preï¬x relation.

(cid:100)ğ‘˜ (cid:52) C2, where C1

Chain Growth (CG); with parameters ğœ âˆˆ (0, 1] and ğ‘  âˆˆ N. Consider C, a
blockchain possessed by an alert party at the onset of a slot sl. Let sl1
and sl2 be two previous slots for which sl1 + ğ‘  â‰¤ sl2 â‰¤ sl, so sl1 is at least ğ‘ 
slots prior to sl2. Then |C[sl1, sl2]| â‰¥ ğœ Â· ğ‘ . We call ğœ the speed coeï¬ƒcient.

Chain Quality (CQ); with parameters ğœ‡ âˆˆ (0, 1] and ğ‘˜ âˆˆ N. Consider any
portion of length at least ğ‘˜ of the blockchain corresponding by an alert
party at the onset of a slot; the ratio of blocks originating from alert
parties in this portion is at least ğœ‡, called the chain quality coeï¬ƒcient.

3 Preliminaries

In this section we provide several requisite deï¬nitions of SNARK systems which
we use to construct a succinct blockchain.

8

Notations. We use the abbreviation PPT to stand for probabilistic polyno-
mial time. We use ğœ† to denote the security parameter.

Deï¬nition 3.1 (SNARKs). Let ğ‘… = {(ğœ™, ğ‘¤)} be a polynomial relation of state-
ments ğœ™ and witnesses ğ‘¤. A Succinct Non-interactive ARgument of Knowledge
for ğ‘… is a quadruple of algorithms (sSetup, sProve, sVerify, sSim), which is com-
plete, succinct and knowledge sound (deï¬ned below) and works as follows:

â€¢ (srs, ğœ) â† sSetup(ğ‘…): The setup algorithm generates the structured ran-

dom string srs and a trapdoor ğœ.

â€¢ ğœ‹ â† sProve(srs, ğœ™, ğ‘¤): the prover algorithm generates a proof ğœ‹.

â€¢ (cid:62)/âŠ¥ â† sVerify(srs, ğœ™, ğœ‹): the veriï¬er algorithm veriï¬es a given proof.

â€¢ ğœ‹ â† sSim(srs, ğœ™, ğœ): the PPT simulator simulates a proof without the

witness but by using the trapdoor.

It simply states that given a true statement, a prover with a
Completeness.
witness can convince the veriï¬er. That is, for every (srs, ğœ) â† sSetup(ğ‘…) and
ğœ‹ â† sProve(srs, ğœ™, ğ‘¤), we have that (cid:62) â† sVerify(srs, ğœ™, ğœ‹).

Succinctness.

It states that the proof size |ğœ‹| is poly(ğœ†).

Knowledge soundness.
It states that whenever somebody produces a valid
argument it is possible to extract a valid witness from their internal data. For-
mally, for every PPT adversary A, there exists a PPT extractor ğœ’A, such that
the following probability is negligible in ğœ†:

(srs, ğœ) â† sSetup(ğ‘…)
(ğœ™, ğœ‹) â† A (srs)
ğ‘¤ â† ğœ’A (transA)

:

Pr

ï£®
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

(ğœ™, ğ‘¤) âˆ‰ ğ‘…
ï£¹
ï£º
âˆ§
ï£º
ï£º
sVerify(srs, ğœ™, ğœ‹) â†’ (cid:62)
ï£º
ï£»

Simulation-extractable SNARKs. A simulation-extractable SNARK is a
SNARK that achieves a higher level of security, namely, simulation extractabil-
ity. The notion of simulation extractability is similar to the notion of knowledge
soundness except that an adversary gets to see also simulated proofs.

Signatures of Knowledge (SoK). An SoK is a generalization of digital sig-
natures by replacing a public key with an instance in an NP language. For
a formal deï¬nition, see [15]. The notion of SoKs is related to the notion
of simulation-extractable non-interactive zero-knowledge arguments, such as,
SNARKs. In fact, [15] showed that the former can be constructed based on the
latter. In this work, we rely on SoKs constructed using SNARKs, thereby being
able to exploit succinctness of such SoKs.

9

4 Mina: A Succinct Blockchain based on Recur-

sive SNARKs

In this section, we introduce a succinct blockchain construction called Mina
based on SNARKs. At a high-level, validity of a blockchainâ€™s sequence of tran-
sitions is proved using a SNARK. Then, the blockchain proof consists of this
SNARK and omits the detailed list of blocks, since verifying the SNARK veri-
ï¬es the embedded blocks. Succinctness of SNARK ensures succinctness of the
blockchain.

Note that a blockchain is dynamic and new blocks keep getting added to
it. However, we would like to ensure succinctness at any given point in time.
Therefore, as the blockchain â€œgrowsâ€, we compute a new SNARK proof that not
only validates the new blocks, but also the existing SNARK proof itself. The
notion of a SNARK proof that attests to the veriï¬ability of another SNARK
proof is the notion of â€œincrementally-computable SNARKâ€ [23, 7, 5].

We will ï¬rst specify the SNARK construction and then demonstrate how it

can be employed to achieve a succinct blockchain.

4.1

Incrementally-computable SNARKs

We now recall the notion of incrementally-computable SNARKs described var-
iously in [23], [7] and [5]. Instead of phrasing the construction in the language
of incrementally veriï¬able computation as in [23] or in the language of PCD
(proof-carrying data) systems as in [7] and [5], we opt to describe it in terms
of state-transition systems as it maps more clearly onto the application of pro-
ducing a succinct blockchain.

We will ï¬rst recall the deï¬nition of a state transition system.

Deï¬nition 4.1 (State transition system). A state transition system is a
tuple (ğ›´, T, Update), where ğ›´ is the set of states, T is the set of transitions and
Update is a (non-deterministic) poly-time computable function Update : TÃ—ğ›´ â†’
ğ›´. Update may also â€œthrow an exceptionâ€ (i.e., fail to produce a new state for
certain inputs). Moreover, elements in ğ›´ and T need to be representable by
bit-strings of length poly(ğœ†).

We now deï¬ne SNARKs for state transition systems. At a high level, we
would like poly(ğœ†)-size proofs (which are veriï¬able in poly(ğœ†) time) which attest
to statements of the form â€œthere exist a state Ïƒ1 and a sequence of transitions
ğ‘¡1, . . . , ğ‘¡ğ‘˜ âˆˆ T such that Update(ğ‘¡ğ‘˜ , Update(ğ‘¡ğ‘˜âˆ’1, . . . , Update(ğ‘¡1, Ïƒ1))) = Ïƒ2â€.
In other words, we would like succinct certiï¬cates of the existence of state-
transition sequences joining two states. The application to blockchains is the
following: we will take our state to be the database of accounts (along with
some metadata needed for correctly validating new blocks) and transitions to
be blocks.

Deï¬nition 4.2 (Incrementally-computable SNARKs). An incrementally-comp-
utable SNARK for a state transition system (ğ›´, T, Update) is a tuple of algo-

10

rithms (sSetup, sProve, sVerify, sSim) such that the following holds. Suppressing
parameter generation and passing the parameters to sProve and sVerify,

1. (sSetup, sProve, sVerify, sSim) is a SNARK.

(sSetup, sProve, sVerify, sSim) is a SNARK for the relation ğ‘… = {(Ïƒğ‘–+ğ‘˜ ),
Ïƒğ‘–, ğ‘¡ğ‘–+1, . . . , ğ‘¡ğ‘–+ğ‘˜ )}, where, Ïƒğ‘–+ğ‘˜ = Update(ğ‘¡ğ‘–+ğ‘˜ , Update(ğ‘¡ğ‘–+ğ‘˜âˆ’1, . . . , Update
(ğ‘¡ğ‘–+1, Ïƒğ‘–))) for any ğ‘˜.

2. (sSetup, sProve, sVerify, sSim) is succinct.

Every honestly generated proof has size poly(ğœ†) and for any ğœ‹, Ïƒ, we have
that sVerify(Ïƒ, ğœ‹) runs in time poly(ğœ†).

4.1.1

Incrementally-computable SNARKs using Recursive Proof Com-
position

NaÂ¨Ä±ve recursive composition is theoretically viable, since, for a SNARK, proof
veriï¬cation is asymptotically cheaper than merely verifying the corresponding
NP statement. However, it is extremely expensive. Although SNARK veriï¬ers
execution is quite fast â€“ in the order of just a few milliseconds on a desktop
computer, generating a SNARK proof to attest to an accepting veriï¬er circuit
is expensive. This is because, executing the veriï¬ers still takes millions of steps
in computation, proving which is impractical even for a single layer of recursion,
as explained in [5].

To address this, we employ the â€œcycle of elliptic curvesâ€ technique (as de-
scribed in [5]) in which two SNARK constructions â€“ classically called Tick and
Tock â€“ are designed such that each can eï¬ƒciently verify proofs from the other.
Then, we deï¬ne the Tick and Tock SNARKs to result in a â€œbinary tree of proofsâ€
as follows. A Tick SNARK is used to certify state transitions at the â€œbaseâ€ of
the tree. Then, to enable eï¬ƒcient merging of those proofs, each of them is
â€œwrappedâ€ using a Tock SNARK. Then, two Tock proofs are merged using a
Tick SNARK.

Therefore, note that, we will need two Tick SNARKs - one for proving state
transitions and another for merging two Tock proofs. And we will need one
Tock SNARK to wrap a Tick proof into a Tock proof. More formally:

1. The base SNARK. A Tick-based SNARK for certifying single state tran-

sitions, which we will call the â€œbaseâ€ SNARK.
Statement: (Ïƒ1, Ïƒ2) âˆˆ ğ›´ 2.
Witness: ğ‘¡ âˆˆ T.
Computation: There exists ğ‘¡ âˆˆ T such that Update(ğ‘¡, Ïƒ1) = Ïƒ2.
We will denote the proof by Ïƒ1 â†’Tick Ïƒ2.

2. The merge SNARK. A Tick-based SNARK for merging two Tock proofs,

which we will call the â€œmergeâ€ SNARK.
Statement: (Ïƒ1, Ïƒ3) âˆˆ ğ›´ 2.

11

Witness: Ïƒ2 âˆˆ ğ›´ and Tock-proofs ğœ‹1, ğœ‹2.
Computation: There exist Ïƒ2 âˆˆ ğ›´ and Tock-proofs ğœ‹1, ğœ‹2 such that
VerifyTock((Ïƒ1, Ïƒ2), ğœ‹1) and VerifyTock((Ïƒ2, Ïƒ3), ğœ‹2)
We will denote the proof by Ïƒ1 â†’Tick Ïƒ3. Ïƒ1 to Ïƒ2 and a SNARK proof
certifying the existence of transitions from Ïƒ2 to Ïƒ3.

3. The wrap SNARK. A Tock-based SNARK for wrapping a Tick proof,

which we will call the â€œwrapâ€ SNARK.
Statement: (Ïƒ1, Ïƒ2) âˆˆ ğ›´ 2.
Witness: A Tick proof ğœ‹.
Computation: There exists a Tick proof ğœ‹ such that VerifyTick((Ïƒ1, Ïƒ2), ğœ‹).
We will denote the proof by Ïƒ1 â†’Tock Ïƒ2.This SNARK merely wraps a
Tick SNARK into a Tock SNARK so that another Tick SNARK can verify
it eï¬ƒciently.

4.1.2 An example transition system

To illustrate this, weâ€™ll show how it can be applied to prove statements in a very
simple transition system where each state is simply the hash H of the previous
for some ğ‘˜, starting
state. Assume the current state is ğ‘¥ (cid:48) = H(H(. . . H(ğ‘¥) . . . ))
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:125)

(cid:124)
from an initial state ğ‘¥. We apply the above technique with our state ğ›´ being the
union of domain and range of H, ğ‘‡ being a singleton set containing an empty
string, and the update function being Update(ğ‘¡, ğ‘¥) = H(ğ‘¥).

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

(cid:123)(cid:122)
ğ‘˜

This gives us a SNARK for proving that there exists a sequence of transi-
tions (ğ‘¡1, . . . , ğ‘¡ğ‘˜ ) such that Update(ğ‘¡ğ‘˜ , Update(ğ‘¡ğ‘˜âˆ’1, . . . , Update(ğ‘¡1, ğ‘¥), . . . )) = ğ‘¥ (cid:48),
which since Update(ğ‘¡, ğ‘¦) = H(ğ‘¦) gives us exactly what we want. For strings
ğ‘¥0, ğ‘¥4 with H(H(H(H(ğ‘¥0)))) = ğ‘¥4, the tree of SNARK proofs appears as follows:

ğ‘¥0 â†’Tick ğ‘¥4

ğ‘¥0 â†’Tock ğ‘¥2

ğ‘¥0 â†’Tick ğ‘¥2

ğ‘¥2 â†’Tock ğ‘¥4

ğ‘¥2 â†’Tick ğ‘¥4

ğ‘¥0 â†’Tock ğ‘¥1

ğ‘¥1 â†’Tock ğ‘¥2

ğ‘¥2 â†’Tock ğ‘¥3

ğ‘¥3 â†’Tock ğ‘¥4

ğ‘¥0 â†’Tick ğ‘¥1

ğ‘¥1 â†’Tick ğ‘¥2

ğ‘¥2 â†’Tick ğ‘¥3

ğ‘¥3 â†’Tick ğ‘¥4

4.2 Mina: A Succinct Blockchain Using Incrementally-

computable SNARKs

In this section, we present the Mina protocol, a succinct blockchain based
on incrementally-computable SNARKs. Intuitively, blockchain updates can be

12

seen as a state transition system, and thus incrementally-computable SNARKs
(which are simply SNARKs for state transition systems) can enable the con-
struction of succinct blockchains.

4.2.1 Our Construction

In this section, we present the Mina protocol. Speciï¬cally, we discuss the details
for generic Turing-complete functionalities that transform a database. Then, in
Section 5, we will instantiate the protocol with the payments functionality.

At a high level, we will treat a blockchain as a state transition function.
Consider, for example, a UTXO (Unpaid Transaction Output) model wherein
every party has an â€˜accountâ€™ with some â€˜balanceâ€™, like in Bitcoin. The state of
the blockchain is a database (such as a Merkle tree) of all the account balances.
A transition is transfer of some part of the balance from one account to another
account. While this is just an example, our protocol is generic and considers
any state set ğ›´ (cid:48) and a Turing-complete transition function Update(cid:48) with some
transition set T(cid:48); that is, we begin with (ğ›´ (cid:48), T(cid:48), Update(cid:48)).

Then, the Mina protocol for (ğ›´ (cid:48), T(cid:48), Update(cid:48)) is constructed as follows. We
employ our consensus protocol, namely Ouroboros Samasika, that we present
in Section 7. We will combine (ğ›´ (cid:48), T(cid:48), Update(cid:48)) and the consensus protocol
to construct a new state transition system (ğ›´, T, Update), mainly to subsume
consensus veriï¬cation in the update function. An incrementally-computable
SNARK for (ğ›´, T, Update) is employed and the proofs attest to the current
state being computed correctly. The blockchain summary simply consists of
the state in ğ›´ and the proof. A blockchain summary producer will just be a
prover and a full node will only need to perform proof veriï¬cation to verify the
blockchain correctness.

Having described the protocol at an intuitive level, we will now discuss the
details. Given (ğ›´ (cid:48), T(cid:48), Update(cid:48)) and a collision-resistant hash function H, the
protocol components are as follows.

The Mina Protocol

The Mina protocol has the following components.

â€¢ Consensus mechanism (UpdateConsensus, VerifyConsensus): The
consensus mechanism is the Ouroboros Samasika protocol that we
present in Section 7. In Ouroboros Samasika VerifyConsensus runs
in time poly(ğœ†), as required.

â€¢ Blocks: Consider a transition ğ‘¡ (cid:48)

corresponding block ğµğ‘– = (snğ‘–, stğ‘–, ğœ‹ğµ
with stğ‘– = ğœ(cid:48)

ğ‘– = consensusProof ğ‘– and ğ‘‘ğ‘– = ğ‘¡ (cid:48)
ğ‘– .

ğ‘–âˆ’1, ğœ‹ğµ

ğ‘– âˆˆ ğ‘‡ ğ‘ğ‘¢(cid:48) that acts on a state ğœ(cid:48)

ğ‘–âˆ’1. The
ğ‘– , ğ‘‘ğ‘–, b-pkğ‘–, ğ‘-sigğ‘–) is constructed

â€¢ State transition system for SNARK: Consider the state transi-
tion system (ğ›´, T, Update) deï¬ned as follows:
ğ›´ = {H(ğœ(cid:48)),
consensusState}ğœ(cid:48) âˆˆğ›´ (cid:48),consensusState. A transition is a block. The func-

13

tion Update(ğµğ‘–, ğœğ‘–âˆ’1) veriï¬es if H(stğ‘–) = ğœğ‘–âˆ’1, the signature veri-
ï¬es in the block veriï¬es and that VerifyConsensus(consensusStateğ‘–âˆ’1,
consensusProof ğ‘–), where consensusStateğ‘–âˆ’1 is part of ğœğ‘–âˆ’1 and ğœ‹ğµ
ğ‘– con-
tains consensusProof ğ‘–.

â€¢ Blockchain summary: The blockchain summary consists of a state

in ğ›´ and a proof snarkğ‘–.

â€¢ VerifyChainSummary(Sğ‘–âˆ’1 = (ğœğ‘–, snarkğ‘–)): As mentioned earlier, this
algorithm simply veriï¬es the proof snarkğ‘– against the statement ğœğ‘–.

â€¢ VerifyBlock(Sğ‘–1

, ğµğ‘–): This algorithm, simply checks the consistencies,
namely, verifying consensus, verifying signature and verifying that
the state in Sğ‘–1 is the hash of the state in the block.

â€¢ UpdateChainSummary(Sğ‘–âˆ’1, ğµğ‘–): Let Sğ‘–âˆ’1 = (ğœğ‘–âˆ’1, snarkğ‘–âˆ’1). This
algorithm runs the Update function as Update(ğµğ‘–, ğœğ‘–âˆ’1) to obtain
ğœğ‘–. Then, it veriï¬es the proof snarkğ‘–âˆ’1. Finally, it runs the prover to
obtain the new proof snarkğ‘–.

Figure 3: The Mina protocol.

Remark 4.1. We assume that the length of the blockchain does not aï¬€ect chain
extractability, because no evidence suggests otherwise for the constructions of
SNARKs that we use, as also noted in [6].

5 The Mina Protocol for Payments

In this section, we will focus on the payments application, where each party has
an account with some balance and a transaction moves a part of its balance to
a diï¬€erent partyâ€™s account.

In the following, we will ï¬rst specify the payments application framework
followed by the underlying SNARK construction and then present the Mina
protocol for payments.

5.0.1 Minaâ€™s Framework for Payments

Let U be a set of parties. The framework consists of the following notions.

â€¢ Accounts. Every party is said to have an account characterized by
(pk, balance, nonce), with pk the partyâ€™s public key for authorizing pay-
ments, balance âˆˆ N, and nonce âˆˆ I which functions to prevent transaction
replay.

â€¢ Ledger. We deï¬ne a ledger as the list of all the accounts. We will refer to
a partyâ€™s account by L(pk) and the ï¬elds of the account, such as balance,
by L(pk).balance.

14

â€¢ Transaction. A transaction is a transfer of value amt from a Senderâ€™s
account L(pkğ‘ ).balance to a Receiverâ€™s account L(pkğ‘Ÿ ).balance. It is repre-
sented as txn = (pkğ‘ , pkğ‘Ÿ , amt, nonceğ‘ , sigğ‘ ), where pkğ‘ , pkğ‘Ÿ are the Senderâ€™s
and the Receiverâ€™s public keys, respectively, nonceğ‘  is the nonce in the
Senderâ€™s account and sigğ‘  is a signature on (pkğ‘Ÿ , amt, nonceğ‘ ) by the Sender.

â€¢ Transaction veriï¬cation. Given a transaction txn and a ledger L, the

following algorithm veriï¬es validity of the transaction.

VerifyTransaction(txn = (pkğ‘ , pkğ‘Ÿ , amt, nonceğ‘ , sigğ‘ ), L):
assert (L(pkğ‘ ).balance â‰¥ amt);
assert (L(pkğ‘ ).nonce = nonceğ‘ );
assert (VerifySig(pkğ‘ , (pkğ‘Ÿ , amt, nonceğ‘ ), sigğ‘ ) = (cid:62));
return (cid:62)

â€¢ Ledger update. Given a ledger L and a set of transactions {txn =
(pkğ‘ , pkğ‘Ÿ , amt, nonceğ‘ , sigğ‘ )}, the following algorithm processes the set by
updating the ledger.

UpdateLedger(L, {txn}):
âˆ€txn âˆˆ {txn}
- L(pkğ‘ ).balance â† L(pkğ‘ ).balance âˆ’ amt;
- L(pkğ‘Ÿ ).balance â† L(pkğ‘Ÿ ).balance + amt;
- L(pkğ‘ ).nonce â† L(pkğ‘ ).nonce + 1;
return L

5.0.2 The SNARK

We will now describe the incrementally-computable SNARK S used for con-
structing our succinct blockchain. Recall that a state transition system charac-
terizes an incrementally-computable SNARK (cf. Deï¬nition 4.2). S is speciï¬ed
in Figure 4.

SNARK S

Let H be a collision-resistant hash function. S is deï¬ned as an incrementally-
computable SNARK for the following state transition system (ğ›´, T, Update):

â€¢ ğ›´ is the set {Ïƒ}ğ‘– of pairs of ledger hash values and consensus states

{(ledgerHashğ‘–, consensusStateğ‘–)}.

â€¢ T is the set of blocks ğµğ‘–

is of the form (ğ‘–, Lğ‘–âˆ’1, consensusProof ğ‘–,
{txn ğ‘— } ğ‘— , b-pkğ‘–, ğ‘-sigğ‘–), {txn ğ‘— } ğ‘— is a set of transactions and b-pkğ‘– is a
public key for verifying the signature ğ‘-sigğ‘–.

â€¢ The function Update(ğ‘¡ğ‘–, Ïƒğ‘–âˆ’1) â†’ Ïƒğ‘– is deï¬ned as follows:

15

Update(ğ‘¡ğ‘–, Ïƒğ‘–âˆ’1) â†’ Ïƒğ‘–:

assert (VerifyTransaction(txn ğ‘— , Lğ‘–âˆ’1) = (cid:62)), âˆ€txn ğ‘— ;
assert (ledgerHashğ‘–âˆ’1 = H(Lğ‘–âˆ’1));
assert (VerifyConsensus(consensusStateğ‘–âˆ’1,

consensusProof ğ‘–) = (cid:62));

assert (VerifySig(b-pkğ‘–, ğ‘š, ğ‘-sigğ‘–) = (cid:62)), where ğ‘š =

(ğ‘–, Lğ‘–âˆ’1, consensusProof ğ‘–, {txn ğ‘— } ğ‘— );

Lğ‘– â† UpdateLedger(Lğ‘–âˆ’1, {txn ğ‘— } ğ‘— );
ledgerHashğ‘– â† H(Lğ‘–);
consensusStateğ‘– â† UpdateConsensus(
consensusStateğ‘–âˆ’1, consensusProof ğ‘–);
return Ïƒğ‘– â† (ledgerHashğ‘–, consensusStateğ‘–)

Figure 4: The underlying SNARK S.

5.0.3 Our Construction

Let (VerifyConsensus, UpdateConsensus) be the Ouroboros Samasika consensus
mechanism. Let H be a collision-resistant hash function. The Mina protocol is
deï¬ned as follows.

The Mina Protocol for Payments

The Mina protocol for payments, deï¬ned in the framework from Section
5.0.1, is based on the SNARK in Figure 4. It has the following components.

â€¢ A blockchain Cğ‘–âˆ’1. A blockchain consists of the hash of the current
ledger, the current consensus state and a SNARK proof. That is,

Cğ‘–âˆ’1 = (ledgerHashğ‘–âˆ’1

, consensusStateğ‘–âˆ’1, snarkğ‘–âˆ’1)

.

â€¢ A block ğµğ‘–. Recall that a block in general is of the form ğµğ‘– =
ğ‘– , ğ‘‘ğ‘–, b-pkğ‘–, ğ‘-sigğ‘–), where snğ‘–, b-pkğ‘–, ğ‘-sigğ‘– are serial number,
ğ‘– , ğ‘‘ğ‘–) by the

(snğ‘–, stğ‘–, ğœ‹ğµ
block proposerâ€™s public key and a signature on (snğ‘–, stğ‘–, ğœ‹ğµ
block proposer, respectively. stğ‘–, ğœ‹ğµ

ğ‘– , ğ‘‘ğ‘– are speciï¬ed as follows.

â€“ stğ‘– = Lğ‘–âˆ’1;
â€“ ğœ‹ğµ
â€“ ğ‘‘ğ‘– = {txn ğ‘— } ğ‘— .

ğ‘– = consensusProof ğ‘–;

16

The algorithms VerifyBlock, UpdateChain, VerifyChain are deï¬ned as

follows.

â€¢ VerifyBlock(Sğ‘–âˆ’1, ğµğ‘–) â†’ (cid:62)/âŠ¥:

assert (H(Lğ‘–âˆ’1) = ledgerHashğ‘–âˆ’1);
assert (VerifyConsensus(consensusStateğ‘–âˆ’1,

consensusProof ğ‘–) = (cid:62));

âˆ€ ğ‘—assert (VerifyTransaction(txn ğ‘— , Lğ‘–âˆ’1) = (cid:62));
assert (VerifySig(b-pkğ‘–, ğ‘š, sigğ‘–) = (cid:62)),

where ğ‘š = (snğ‘–, Lğ‘–âˆ’1, consensusProof ğ‘–, {txn ğ‘— } ğ‘— )

return (cid:62)

â€¢ UpdateChainSummary(Sğ‘–âˆ’1, ğµğ‘–) â†’ Cğ‘–:

, consensusStateğ‘–âˆ’1);

assign Ïƒğ‘–âˆ’1 â† (ledgerHashğ‘–âˆ’1
Ïƒğ‘– â† Update(ğµğ‘–, Ïƒğ‘–âˆ’1);
snarkğ‘– â† sProve(Ïƒğ‘–, (Ïƒğ‘–âˆ’1, ğ‘¡ğ‘–));
assign Sğ‘– â† (Ïƒğ‘–, snarkğ‘–);
return Sğ‘–

â€¢ VerifyChainSummary(Sğ‘–) â†’ (cid:62)/âŠ¥:

assign Ïƒğ‘– â† (ledgerHashğ‘–, consensusStateğ‘–);
return sVerify(Ïƒğ‘–, snarkğ‘–)

Figure 5: The Mina protocol for payments.

6 Snark Workers

In this section, we will introduce two optimization techniques, namely, â€˜parallel
scan stateâ€™ and â€˜prover incentivesâ€™. They both target the following issue.

The issue. Observe from Figure 3 that to compute Sğ‘–, we need Sğ‘–âˆ’1. Thus,
there is a sequential dependency for SNARK proof computation. As a result, a
naÂ¨Ä±ve implementation suï¬€ers from a block time that is at least the time required
to compute the proof. Furthermore, it suï¬€ers from high memory requirements
for block proposers due to high transaction latency (where, transaction latency
is the time required for a transaction to be summarized in a SNARK proof).

17

The solution. The goal is to design techniques that maximize the through-
put. Speciï¬cally, our goal is to maximize the rate at which transactions can
be processed and validated in the Mina protocol network. This enables more
simultaneous users on the network.

6.1 Parallel Scan State

Recall that a raw chain of blocks is inherently sequential (i.e., cannot be par-
allelized in general). However, thanks to incremental computability of the
SNARK, the SNARK work can be parallelized. This is the key observation
that leads to the notion of a â€˜parallel scan stateâ€™, where we decouple producing
a block from computing SNARK proofs.

We maintain a special queue, called the work queue, where we enqueue new
blocks as they are proposed. In other words, it is a queue of the â€˜SNARK workâ€™
to be performed by the network.

The network then computes the SNARK proofs in parallel; a tree of proofs
is computed where the leaves correspond to the proofs proving validity of single
blocks and the other proofs simply attest to the correctness of their children
proofs. Finally, the root proof attests to correctness of all the blocks corre-
sponding to the leaves of the tree. Consider, for example, a sequence of blocks
ğµğ‘–, ğµğ‘–+1, . . . , ğµ ğ‘— in the work queue. The root proof attests to the validity of each
of the blocks. This root proof can be combined with the SNARK proof for
the validity of Sğ‘–âˆ’1 to result in a SNARK proof that attests to the validity of
S ğ‘— . This is illustrated in Figure 6. Note that this tree, under the hood, works
similarly to the example transition system described in Section 4.1.2.

Figure 6: A snapshot of a parallel scan state.

Observe that, by careful design of parallelism, we can ensure that the through-
put completely keeps up with the rate transactions are added, which is optimal.
While the transaction latency in the naÂ¨Ä±ve approach was ğ‘‚ (ğ‘…), where ğ‘… is the
rate at which blocks are produced, in the proposed approach, the transaction
latency is ğ‘‚ (log(ğ‘…)). With a careful designing of data structure, the storage
requirement can be reduced from ğ‘‚ (ğ‘…) in the naÂ¨Ä±ve approach to 2ğ‘… âˆ’ 1 + ğ‘‚ (1)
in the proposed approach; we will omit the details of the data structure [?].

6.2

Incentivizing the Provers

A party that generates SNARK proofs is called a snarker. We will describe
prover incentives with the goal of achieving lowest possible transaction latency

18

(i.e., to minimize the time gap between when a block is produced and when it
is absorbed in the blockchainâ€™s SNARK proof).

The proposed incentive structure is the following. Every block producer that
pushes a block to the work queue is required to pop a block by generating a
It posts a fee request together with the SNARK
proof validating the block.
proof it generates. It also includes a transaction in the same block that pays
the fee to the prover that will compute the snark for that block. Typically, the
fees are paid out from the transaction fees the block producer would otherwise
receive.

In essence, there is a lowest-price auction for each piece of SNARK work.
Block producers would like to pay snarkers as little as possible for their proofs
and snarkers would like to receive as high a fee as possible for their proofs.
Therefore, enforcing a block producer to also be a prover but for a diï¬€erent
block enforces stability in the system.

Note that this notion is similar to the aforementioned naÂ¨Ä±ve approach in that
a block producer also computes a SNARK proof, but with the diï¬€erence that
the block producer computes proof for the block in the head of the queue.

Remark 6.1. Given a proof and an associated fee request, we require that an
adversary cannot maul the fee request. Otherwise, an attacker could pass-oï¬€
a diï¬€erent partyâ€™s proof as their own (by replacing the public key) or modify
someoneâ€™s fee request.

Signatures of knowledge are a cryptographic primitive that allows us to
accomplish exactly this, as recalled in Section 3. In Mina, we use a construction
based on the Boweâ€“Gabizon simulation-extractable SNARK [8].

7 Ouroboros Samasika â€“ PoS Consensus for Suc-

cinct Blockchains

One of the main technical contributions of this paper is the ï¬rst provably-secure
proof-of-stake consensus protocol for a succinct blockchain. Existing protocols
are either not adaptively secure or rely on a centralized trusted third party for
checkpointing advice to nodes trying to bootstrap or rely on arbitrary informa-
tion in the history of the protocol for chain selection, immediately rendering the
protocol incompatible for succinct settings [16, 12, 3, 11].

We construct a consensus protocol that is secure against adaptive corruption
and does not require a trusted checkpointing service for bootsrapping, is adap-
tively secure and, most importantly, succinct. That is, it requires only succinct
information to tell apart honest chains from dishonest ones, immaterial of how
far in history they had forked. Our starting point is the Ouroboros Genesis [3]
(sometimes referred to as Genesis in this paper) PoS consensus protocol.

Ouroboros Genesis already enjoys adaptive security and oï¬€ers boostrapping
from Genesis. However, the chain selection rules require information about an
arbitrary distance in a chainâ€™s history; this is natural, since, an adversary might
modify arbitrary aspects of the blockchain to create a fork and the timing of

19

the fork might be learned by parties long after it has occurred. For this reason,
Ouroboros Genesis by itself is not usable in the succinct setting. The challenge
is to somehow craft a constant-sized summary of the history that suï¬ƒces in
correctly choosing one chain from multiple candidates.

In this section, we present

Protocolboros wherein we resolve the above challenge. Speciï¬cally, we demon-
strate an approach to succinctly summarize the information necessary to cor-
rectly arbitrate chains with long-range forks.

7.1

Intuitive Description

In this part of the section, we will particularly focus on the core of a consen-
sus protocol, namely, the chain selection rules. The entire consensus protocol
appears in detail, along with the proofs of security, in Section 7.3.
We will begin by recalling the rules of Ouroboros Genesis.

The chain selection rules of Ouroboros Genesis. There are two chain
selection rules in Ouroboros Genesis. One is when the fork is a short-range one;
in this case, the rule is simply to choose the longest chain. The other is when
the fork is a long-range one; in this case, one may not simply choose the longest
chain, since an adversary could have posed various attacks over time to perhaps
skew the leader selection distribution and managed to create a longer chain.
Therefore, for long-range forks, the rule is to limit the comparison of chains to
just a few slots immediately following the fork.

Note that the rule for long-range forks requires information at arbitrary
times in the history. Clearly, it is not trivial to summarize the information
succinctly.

We now present the chain selection rules of

Protocolboros.

The chain selection rules of
Protocolboros. Similar to Genesis,
Protocolboros also has two consensus rules applicable depending on how far in
history the fork has occurred.

Short-range fork rule. Roughly speaking, this rule is triggered whenever the
fork is in such a way that the adversary has not yet been able to modify
the block density distribution and the rule is to simply choose the longest
chain. While the action of the rule is the same as in Ouroboros Genesis,
the predicate for deciding whether a given fork is a short-range one or not
is slightly diï¬€erent. Since the main contribution is the long-range fork
rule, we defer the exact description of the predicate to Appendix 7.7.

Long-range fork rule. This rule is applied for forks that occurred more than
ğ‘˜ blocks ago. Before we describe the rule itself, following is the intuition.
Firstly, recall the reason why simply the longest chain rule might not

20

choose the right chain in this case; after an adversary creates a fork,
over time, it might skew the leader selection distribution leading to a
longer adversarial chain. Due to this, we can only rely on the density
diï¬€erence in the ï¬rst few slots following the fork (which is indeed what
Ouroboros Genesis utilizes). The challenge is to somehow â€œcarry forwardâ€
the summary of that density diï¬€erence, even when the fork position â€“ and
hence the slot range in question â€“ is not known ahead of time.

The idea. The idea is to consider a moving window of slots and only
store the minimum of all the densities observed so far in that window. Ob-
serve that this idea almost resolves the challenge: for a dishonest chain,
even if the adversary manages to increase the chain density, the minimum
density value points to the window following the fork, providing the re-
quired summary. On the other hand, for the honest chain, there is not a
huge ï¬‚uctuation in the densities and, due to majority stake on the chain,
the minimum density value across the chain is likely to be higher than
that for the dishonest chain.

While this almost completely resolves the challenge, there is one other part
to the challenge we still need to address. Namely, how long the window
should be and how it should slide. This is critical, as it is constrained
by two conï¬‚icting requirements: (1) The max-length of the window, since
post a certain point after the fork, no guarantees can be made on the block
densities in the adversarial chain and (2) The min-length of the window,
since some minimum number of samples are required to tell apart the given
two distributions. Let us call the window of the critical length following
the fork, that satisï¬es both the constrains as the â€œcritical window â€. So
the challenge is to design the window length and its movement so that no
matter where the fork is positioned, the moving window will capture the
entire critical window in one shot. The idea is to have the window length
slightly greater than the critical window length. As far as moving of the
window is considered, ï¬rstly note that a naÂ¨Ä±ve shifting window (where the
next shift moves the beginning of the window to after its current end)
may not capture the entire critical window in any given position, since a
fork can occur at arbitrary slots. The idea is to have the window shift
by a fraction of its size. We call the resulting window as the â€œğœˆ-shifting
Ï‰-windowâ€, where Ï‰ is the window length and ğœˆ is the length by which
it shifts (cf. Deï¬nition 1). With careful calibration of ğœˆ and Ï‰, we can
ensure that the window captures the critical window.

This intuition is formally proven later in Theorem 2.

Below, we formally describe the chain selection rules. Our new chain
selection rule, formally speciï¬ed as algorithm maxvalid-sc(Â·) (see Figure 7),
surgically adapts the chain selection rule of Ouroboros Genesis, namely
maxvalid-bg(Â·) (see Figure 20), but by replacing the long-range fork rule
with a new one. We will continue all the discussions by referring to the

21

underlying blockchains of chain summaries. We will note that the only
information about the underlying blockchains needed in any part of the
consensus mechanism is a ï¬xed number of blocks in the immediate history.
Therefore, the consensus veriï¬cation is succinct.
Here, Cloc is the local chain, N = {C1, . . . , Cğ‘€ } is the list of chains to
choose from. The function isShortRange(C, C (cid:48)) outputs whether or not
the chains fork in the â€œshort rangeâ€ or not. The function getMinDen(C)
outputs the minimum of all the window densities observed thus far in C;
it is formally deï¬ned in Figure 16.

Algorithm maxvalid-sc(Cloc, N = {C1, . . . , Cğ‘€ }, ğ‘˜)

// Compare Cloc with each candidate chain in N

1. Set Cmax â† Cloc

2. for ğ‘– = 1, . . . , ğ‘€ do

if isShortRange(Cğ‘–, Cmax) then // Short-range fork

if |Cğ‘– | > |Cmax| then
Set Cmax â† Cğ‘–

end if

else //Long-range fork

if getMinDen(Cğ‘–) > getMinDen(Cmax) then

Set Cmax â† Cğ‘–

end if

end if

end for

3. return Cmax

Figure 7: The new chain selection rule.

7.2 Background

We introduce many relevant concepts from Ouroboros Genesis which remain
the same in our setting too. We begin by recalling a summary of the Ouroboros
family of protocols.

The Ouroboros family of consensus protocols. Kiayias et al. proposed
the ï¬rst proof-of-stake (PoS) protocol Ouroboros [16] with rigorous security

22

guarantees. However, the adversarial model only considered synchronous net-
works. Here, the protocol execution is divided into time units called slots and
groups of slots form epochs.

The adversarial model was strengthened in the follow-up work Ouroboros
Praos [12] by considering the semi-synchronous setting (where, the protocol
execution is still divided into slots and epochs, but the network could experience
a maximum delay of ğ›¥ slots in delivering messages.) This work introduced the
notion of â€œempty slotsâ€ as an artiï¬cial way to provide short periods of silence
for parties to catch up in the cases of message delivery delays. An important
point to note about the Ouroboros Praos is its chain selection rule. Whenever
there are two chains that have forked â€˜recentlyâ€™ (i.e., when there is a so-called
â€˜short-range fork â€™), it chooses the longer chain. On the other hand, i.e., if the
fork is far back in history (or when there is a so-called â€˜long-range fork â€™), then
it simply relies on a trusted external service (called the checkpointing service)
to provide the advice on the honest chain. Clearly, this introduces a strong
element of centralization which is tackled in the follow up project.

Finally, Ouroboros Genesis overcame the Ouroboros Praosâ€™s drawback
of relying on an external service for resolving long-range forks by providing an
additional chain selection rule [3]. Speciï¬cally, the rule considers a short range ğ‘ 
of slots soon after the long-range fork and chooses the chain with higher density
in those ğ‘  slots.

Modeling time: Slots, epochs and empty slots. The protocol execution
time is divided into epochs which are further divided into slots. There are ğ‘…
slots in an epoch. Like in Ouroboros Praos and Ouroboros Genesis, some slots
can be â€œemptyâ€ (i.e., without any block associated with them). Speciï¬cally, a
consensus parameter, ğ‘“ , denotes the probability that any given slot has a block
producer assigned to it. If no block producer is assigned to a slot, then the slot
is empty (i.e., without a block).

Types of parties. We categorize parties in a way that models various real-life
scenarios, such as, newly joining parties and parties with temporary connectiv-
ity/availability issues, as detailed fully in [3]. The model deï¬nes three kinds of
parties as follows. Alert parties are parties that have access to all the required
resources, and are also synchronized. These parties enjoy full security guar-
antees and we will require a lower bound on their stake (see below) to ensure
security. Potentially active parties (or active, for short) are all parties that,
broadly speaking, might potentially act in the current time slot of the protocol
execution. This includes honest parties that have access to all the required re-
sources as well as adversarial parties. Inactive parties are all other parties, such
as honest parties that cannot access some of the necessary resources to engage
with the protocol, e.g., their network connection.

Stake distributions. The protocol is assumed to maintain the following ra-
tios:

23

â€¢ ğ›¼ â‰¥ 1/2 is the ratio of the alert stake to the active stake.

â€¢ ğ›½ is the ratio of the active stake to the entire stake.

Epoch randomness and leader selection distributions. Stake distribu-
tion considered in an epoch ep is actually the stake distribution at the last slot
of ep âˆ’ 2. Besides stake distribution, the notion of epoch randomness inï¬‚uences
leader selection distribution in any epoch. Speciï¬cally, epoch randomness is
derived as a function of certain blocks information from the ï¬rst two-thirds of
ep âˆ’ 1.

An important remark which we will use in our proofs is the following fact:
Consider a fork at slâˆ—, where a dishonest chain forks from an honest chain. For
ğ‘…/3 slots following slâˆ—, the epoch randomness and leader selection distributions
are guaranteed to be unskewed. However, in the slots following the ğ‘…/3 slots,
no such guarantee can be placed on the distribution in the dishonest chain.

Notations. For a chain C and an interval of slots ğ¼ (cid:52)
= [slğ‘–, sl ğ‘— ] = {slğ‘–, . . . , sl ğ‘— },
we denote by C[ğ¼] = C[slğ‘–, sl ğ‘— ] the sequence of blocks in C such that their slot
numbers fall into the interval ğ¼. We replace the brackets in this notation with
parentheses to denote intervals that do not include endpoints; e.g., (slğ‘–, sl ğ‘— ] =
{slğ‘–+1, . . . , sl ğ‘— }. Finally, we denote by |C[ğ¼]| the number of blocks in C[ğ¼]. We
typically denote a party by ğ‘ƒ.

7.3 The New Chain Selection Rules

In this section, we describe the proposed chain selection rule for the succinct
setting. The description is structured so as to clearly highlight (in blue) the dif-
ferences from the corresponding Ouroboros Genesis protocols and algorithms.
Algorithms/protocols that are completely novel to Ouroboros Samasika have
only their names highlighted; the description is not highlighted for readability.
Moreover, in protocol descriptions, the details that are common to Ouroboros
Samasika and Ouroboros Genesis are mentioned but not delved deep into, so as
to (a) stay focused on the main contribution and (b) maintain a pseudocode
level of description. We defer the reader to [3] for the details common to
Ouroboros Samasika and Ouroboros Genesis. The formal chain selection al-
gorithm maxvalid-sc was presented in Figure 7.

7.3.1 The short-range chain selection rule

Recall that a fork is a short-range one when it can be guaranteed that an
adversary has not yet modiï¬ed the block density distribution. maxvalid-sc calls
the predicate isShortRange that outputs whether a given range is short-range
one or not in this sense. The predicate is described as follows.

24

Algorithm isShortRange(C1, C2)

1. Let prevLockcp

1 and prevLockcp

2 be the prevLockcp components in the

last blocks of C1, C2, respectively.

2. if prevLockcp

1 = prevLockcp

2 then

3.

return (cid:62)

4. else

5.

return âŠ¥

Figure 8: The algorithm to determine when a given fork is a short-range one or
not.

Below in Figure 12 is the protocol executed to select a new chain, denoted

as SelectChain.

Protocol SelectChain(ğ‘ƒ, sid, Cloc, N = {C1, . . . , Cğ‘€ }, ğ‘˜)

// Step 1: Discard invalid chains

1. Initialize Nvalid â† âˆ…

2. for ğ‘– = 1, . . . , ğ‘€ do

Invoke Protocol IsValidChain(ğ‘ƒ, sid, Cloc, Cğ‘–, ğ‘˜); if it returns (cid:62) then
update Nvalid â† Nvalid âˆª {Cğ‘– }
end for

// Step 2: Apply chain selection rule on valid chains

3. Execute Algorithm maxvalid-sc(Cloc, Nvalid, ğ‘˜). Denote the output

chain by Cmax.

4. Set Cloc â† Cmax. Output Cloc.

Output: Output Cloc.

Figure 9: The protocol for parties to select a chain when there is more than
one.

7.4 The Window Min-density

The core concept in the new chain selection rule is that of the window min-
density. As mentioned earlier in this section, the idea is to consider a shifting

25

window and to always maintain a minimum of densities in all the windows so
far.

More formally, we employ a ğœˆ-shifting Ï‰-window (see Deï¬nition 1), wherein

a Ï‰-long window shifts at a time by ğœˆ slots.

Deï¬nition 1 (ğœˆ-shifting Ï‰-window). For ğœˆ, Ï‰ âˆˆ N and 0 < ğœˆ < Ï‰, a ğœˆ-shifting
Ï‰-window over a sequence of slots sl1, sl2, . . . is characterized by an algorithm
shiftWindow that takes as input a variable (or a set of variables) which is a func-
tion of slots in the interval [slğ‘–+1, slğ‘–+Ï‰] and assigns/updates it with a function of
the slots [slğ‘–+1+ğœˆ, slğ‘–+Ï‰+ğœˆ]. We call ğœˆ the shift parameter and Ï‰ the window-length
parameter.

The shift parameter ğœˆ and the window-length parameter Ï‰ are set as follows.
Let ğ‘ CG be the chain growth parameter ensured by the short-range chain selec-
tion rule (which is equivalent to the chain selection rule of Ouroboros Genesis)
(cf. Theorem 2 in [3]).

The starting point for Ouroboros Samasika is Ouroboros Genesis. In Ouroboros

Genesis, a (non-shifting) window of size of the order ğ‘ CG was considered imme-
diately after the fork. In Ouroboros Samasika, due to succinctness, we consider
the window positioning independent of the fork position. However, we do need
to consider a window almost close to the fork. For this reason, we consider a
window of size slightly larger than ğ‘ CG (see (1)) and shift it slightly by ğœˆ slots
as time progresses (see (2)) to capture a window close to the fork. For imple-
mentation purposes, one can imagine ğ‘›ğ‘  sub-windows, each of length ğœˆ slots,
making up a window (see (3)).

Ï‰ = (1 + ğœ–ğ‘ )ğ‘ CG,
ğœˆ = ğœ–ğ‘  ğ‘ CG,
ğ‘›ğ‘  = (1/ğœ–ğ‘ ) + 1,

(1)

(2)

(3)

while ensuring that ğœˆ and 1/ğœ–ğ‘  are whole numbers and that ğœ–ğ‘  > 0. For intuition,
here is an example: Let ğ‘ CG = 6 slots. Let ğœ–ğ‘  = 1/3. Then, the window is of size
Ï‰ = 8 slots, with the shift being ğœˆ = 2 slots long (See Figure 10).

26

Figure 10: An example of the shifting window with ğ‘ CG = 6 slots and ğœ–ğ‘  = 1/3.
Therefore, the window size Ï‰ = 8 slots and the shift size ğœˆ = 2 slots. The ï¬rst
shift occurs when the current time is ğ‘¡2, the second at ğ‘¡3, and so on.

We present an example implementation algorithm in Figures 11 and 13. We
denote the window min-density by minDen. As mentioned earlier, we maintain
ğ‘›ğ‘  sub-windows, each of size ğœˆ slots; namely, pDen1
, . . . , pDenğ‘›ğ‘  . We also main-
tain an additional sub-window pDencurr also of size ğœˆ slots, to keep track of the
density in the ongoing sub-window before there is a shift. The sequence of all
âˆ’âˆ’â†’
Den = (pDen1
these parameters is denoted by

, . . . , pDenğ‘›ğ‘ 

, minDen).

, pDencurr

Algorithm isWindowStop(sl, ğœˆ)

1. if (sl % ğœˆ) = 0

2.

return (cid:62)

3. else

4.

return âŠ¥

Figure 11: The algorithm to check if the end of the window is reached.

Protocol SelectChain(ğ‘ƒ, sid, Cloc, N = {C1, . . . , Cğ‘€ }, ğ‘˜)

// Step 1: Discard invalid chains

1. Initialize Nvalid â† âˆ…

2. for ğ‘– = 1, . . . , ğ‘€ do

Invoke Protocol IsValidChain(ğ‘ƒ, sid, Cloc, Cğ‘–, ğ‘˜); if it returns (cid:62) then
update Nvalid â† Nvalid âˆª {Cğ‘– }
end for

27

// Step 2: Apply chain selection rule on valid chains

3. Execute Algorithm maxvalid-sc(Cloc, Nvalid, ğ‘˜). Denote the output

chain by Cmax.

4. Set Cloc â† Cmax. Output Cloc.

Output: Output Cloc.

Figure 12: The protocol that chooses a chain using maxvalid-sc.

Algorithm shiftWindow(

âˆ’âˆ’â†’
Den)

Let

, . . . , pDenğ‘›ğ‘ 

âˆ’âˆ’â†’
Den = (pDen1
1. Set minDen â† min(minDen, minDen âˆ’ pDen1 + pDencurr)
2. for ğ‘– = 1 to ğ‘›ğ‘  âˆ’ 1

, pDencurr

, minDen).

3.

Set pDenğ‘– â† pDenğ‘–+1

4. end for

5. Set pDenğ‘›ğ‘  â† pDencurr and pDencurr â† 0

6. return (pDen1

, . . . , pDenğ‘›ğ‘ 

, pDencurr

, minDen)

Figure 13: The algorithm to shift the window.

Remark 7.1 (Divisibility of window length by the shift). The requirement of
the shift length ğœˆ completely dividing the window length Ï‰ is only to have clean
algorithm descriptions. All the arguments hold even if it is not the case.

7.5 Adopting the New Chain Selection Rule

We now discuss how the modiï¬cations introduced in the maxvalid-sc algorithm
of Ouroboros Genesis percolates to the other consensus sub-protocols.

âˆ’âˆ’â†’
Den = (pDen1

The

, . . . , pDenğ‘›ğ‘ 

, minDen) parameters are ï¬rst set
, pDencurr
when the Genesis block is generated by running the Initialization-Genesis proto-
col. A party that has been registered with all its resources becomes operational
by invoking this protocol.

28

Algorithm Initialization-Genesis(ğ‘ƒ, sid, ğ‘…, ğ‘›ğ‘ , Ï‰)

1. Send (KeyGen, sid, ğ‘ƒ) to FVRF and FKES; receiving (Veriï¬cationKey, sid,

ğ‘ ) and (Veriï¬cationKey, sid, ğ‘£kes
ğ‘£vrf

ğ‘ ), respectively.

2. if ğœ = 0 then

3.

4.

5.

6.

7.

Send (ver keys, sid, ğ‘ƒ, ğ‘£vrf

ğ‘ , ğ‘£kes

ğ‘ ) to FINIT to claim stake from the

genesis block.

Invoke FinishRound(ğ‘ƒ) and invoke UpdateTime(ğ‘ƒ) to update

ğœ, ep, sl.

while ğœ = 0 do

Call UpdateTime(ğ‘ƒ) to update ğœ, ep, and sl and give up the

activation

end while

8. end if

// The following is executed if this is a non-genesis round.

9. if ğœ > 0 then

10.

11.

12.

13.

14.

15.

Set each of the variables {pDen1

, . . . , pDenğ‘›ğ‘ 

, pDencurr} to âˆ…. Also,

set minDen â† Ï‰.
âˆ’âˆ’â†’
Den = (pDen1

Set

, . . . , pDenğ‘›ğ‘ 

, pDencurr

, minDen).

if FINIT signals an error then

Halt the execution.

end if

Send (genblock req, sid, ğ‘ƒ) to FINIT.

16. Receive from FINIT the response (genblock, sid, G(cid:48) = (S1, ğœ‚1,

âˆ’âˆ’â†’
Den)),

where

S1 = ((ğ‘ˆ1, ğ‘£vrf
1

, ğ‘£kes
1

, ğ‘ 1), . . . , (ğ‘ˆğ‘›, ğ‘£vrf

ğ‘› , ğ‘£kes

ğ‘› , ğ‘ ğ‘›)).

17.

Set CP = (prevLockcp, currStartcp, currStartcp), where, prevLockcp â†

âˆ…, currStartcp â† G(cid:48), currStartcp â† G(cid:48). Also set G â† (G(cid:48)||CP).

18.

Set Cloc â† G. Also, Set ğ‘‡ ep

ğ‘ ) the threshold
for stakeholder ğ‘ƒ for epoch ep, where ğ›¼ep
ğ‘ is the relative stake of
stakeholder ğ‘ƒ in Sep and â„“VRF denotes the output length of FVRF.
ğ‘ , ğ‘£kes
Finally, send (HELLO, sid, ğ‘ƒ, ğ‘£vrf

ğ‘ â† 2â„“VRF ğœ™ ğ‘“ (ğ›¼ep

ğ‘ ) to F new

N-MC.

19. end if

29

20. Set isInit â† (cid:62), ğ‘¡on â† ğœ, and ğ‘¡work â† 0.

Global variables:
ğ‘£vrf
ğ‘ , ğ‘£kes
by all protocol parts.

ğ‘ , ğœ, ep, sl, Cloc, ğ‘‡ ep

The protocol

list of variables
ğ‘ , isInit, and ğ‘¡on to make each of them accessible

stores

the

Figure 14: The initialization protocol of Ouroboros Samasika (run only the ï¬rst
time a party joins).

30

Protocol StakingProcedure(ğ‘ƒ, sid, ğ‘˜, ep, sl, buï¬€er, Cloc)

The following steps are executed in an (MAINTAIN-LEDGER, sid, minerID)-
interruptible manner:

1. Send (EvalProve, sid, nonce ğ‘— (cid:107)sl(cid:107)NONCE) to FVRF, denote the response
from FVRF by (Evaluated, sid, ğ‘¦ğœŒ, ğœ‹ğœŒ). Also, send (EvalProve, sid, nonce ğ‘—
(cid:107)sl(cid:107)TEST)) to FVRF, denote the response from FVRF by (Evaluated, sid,
ğ‘¦, ğœ‹).

2. if ğ‘¦ < ğ‘‡ ep

ğ‘ then

// Generate a new block

3.

4.

5.

6.

7.

8.

9.

10.

11.

12.

Set buï¬€er(cid:48) â† buï¬€er, (cid:174)ğ‘ â† txnğ‘base-tx and st â† blockifyOG( (cid:174)ğ‘)

repeat

Parse buï¬€er(cid:48) as sequence (txn1, . . . , txnğ‘›)

for ğ‘– = 1 to ğ‘› do

if ValidTxOG(txnğ‘–, (cid:174)st(cid:107)st) = 1 then

Set (cid:174)ğ‘ â† (cid:174)ğ‘ (cid:107)txnğ‘–, remove txnğ‘– from buï¬€er(cid:48) and set

st â† blockifyOG( (cid:174)ğ‘)

end if

end for

until (cid:174)ğ‘ does not increase anymore

Set crt = (ğ‘ƒ, ğ‘¦, ğœ‹), ğœŒ = (ğ‘¦ğœŒ, ğœ‹ğœŒ) and â„ â† H(head(Cloc)) and
send (USign, sid, ğ‘ƒ, (â„, st, sl, crt, ğœŒ), sl) to FKES; denote the response
by (Signature, sid, (â„, st, sl, crt, ğœŒ), sl, ğœ).

13.

Update min-density variables as follows:

â€¢ Execute
pDencurr

âˆ’âˆ’â†’
Den â† get
, minDen).

âˆ’âˆ’â†’
Den(Cloc), where

âˆ’âˆ’â†’
Den = (pDen1

, . . . , pDenğ‘›ğ‘ 

,

â€¢ pDencurr â† pDencurr + 1

31

â€¢ if isWindowStop(sl, ğœˆ) then
âˆ’âˆ’â†’
Den)

âˆ’âˆ’â†’
Den â† shiftWindow(

â€¢

â€¢ end if

Set ğµ(cid:48) â† (â„, st, sl, crt, ğœŒ, ğœ,

âˆ’âˆ’â†’
Den)

Update the checkpoints CP as follows:

if slot sl = 1, i.e., the ï¬rst one in the current epoch then

â€¢ Set currStartcp â† ğµ
â€¢ Set prevLockcp â† currStartcp
â€¢ Set currStartcp â† ğµ

else if 1 < sl â‰¤ 2

3 âˆ— ğ‘… then

currStartcp â† ğµ

end if

Set ğµ â† (ğµ(cid:48)||CP) and update Cloc â† Cloc(cid:107)ğµ.

Multicast the

extended chain and wait.

Send (MULTICAST, sid, Cloc) to F bc

N-MC and proceed from here

14.

15.

16.

17.

18.

19.

20.

21.

upon next activation of this procedure.

22. else

23.

Evolve the KES signing key by sending (USign, sid, ğ‘ƒ, 0, sl) to FKES
and set the anchor at end of procedure to resume on next maintenance
activation.

24. end if

Figure 15: The Ouroboros Samasika staking procedure.

In Figure 7.5, we demonstrate where in the protocol architecture to maintain
âˆ’âˆ’â†’
and update the window min-density
Den parameters. Speciï¬cally, we will have
every block hold the current values of these parameters. For any block, the
parameters are generated by the slot leader. Speciï¬cally, the slot leader begins
âˆ’âˆ’â†’
by retrieving
Den for the last block in the chain the party is about to extend.
Then, the party updates the parameters (using algorithms shiftWindow(Â·) and
isWindowStop(Â·, Â·)).

Algorithm getMinDen(C)

32

Let ğµlast be the last block in C.

1. if ğµlast = G then // i.e., if ğµlast is the genesis block

2.

return 0

3. else

4.

5.

Parse ğµlast to obtain the parameter minDen.

return minDen

Figure 16: The protocol to obtain the current window min-density of a given
chain.

7.6 Proofs of Security

In this section, we prove security of the Ouroboros Samasika protocol. We begin
with some preliminaries which will be useful in the proofs.

7.6.1 Preliminaries

In various parts of the proofs, we need to estimate the expected number of
blocks for a given characteristic string. Below, we deï¬ne and design various
tools that will facilitate the estimations.

Many of the arguments employ the Azumaâ€™s inequality (cf. [17], Section 4)

stated below.

Lemma 1 (Azumaâ€™s inequality (Azuma; Hoeï¬€ding)). Let ğ‘‹0, . . . , ğ‘‹ğ‘› be a se-
quence of real-valued random variables so that, for all ğ‘¡, |ğ‘‹ğ‘¡+1 âˆ’ ğ‘‹ğ‘¡ | â‰¤ ğ‘ for some
constant ğ‘. If E[ğ‘‹ğ‘¡+1 | ğ‘‹0, . . . , ğ‘‹ğ‘¡ ] â‰¤ ğ‘‹ğ‘¡ for all ğ‘¡ then for every ğ›¬ â‰¥ 0

Pr[ğ‘‹ğ‘› âˆ’ ğ‘‹0 â‰¥ ğ›¬] â‰¤ exp

(cid:18)

âˆ’

ğ›¬2
2ğ‘›ğ‘2

(cid:19)

.

Alternatively, if E[ğ‘‹ğ‘¡+1 | ğ‘‹0, . . . , ğ‘‹ğ‘¡ ] â‰¥ ğ‘‹ğ‘¡ for all ğ‘¡ then for every ğ›¬ â‰¥ 0

Pr[ğ‘‹ğ‘› âˆ’ ğ‘‹0 â‰¤ âˆ’ğ›¬] â‰¤ exp

(cid:18)

âˆ’

ğ›¬2
2ğ‘›ğ‘2

(cid:19)

.

Another large deviation bound that we use in our probabilistic arguments is

the Chernoï¬€ bound, recalled below.

Theorem 1 (Chernoï¬€ bound.). Let ğ‘‹1, . . . , ğ‘‹ğ‘› be independent random vari-
ables with E[ğ‘‹ğ‘–] = ğ‘ğ‘– and ğ‘‹ğ‘– âˆˆ [0, 1]. Let ğ‘‹ = (cid:205)ğ‘›
ğ‘ğ‘– = E[ğ‘‹].
ğ‘–=1

ğ‘‹ğ‘– and ğœ‡ = (cid:205)ğ‘›
ğ‘–=1

33

Then, for all ğ›¬ â‰¥ 0,

ğ‘ƒğ‘Ÿ [ğ‘‹ â‰¥ (1 + ğ›¬)ğœ‡] â‰¤ ğ‘’âˆ’ ğ›¬2
ğ‘ƒğ‘Ÿ [ğ‘‹ â‰¥ (1 + ğ›¬)ğœ‡] â‰¤ ğ‘’âˆ’ ğ›¬2

2+ğ›¬ ğœ‡

2+ğ›¬ ğœ‡

Deï¬nition 2 (The super-binomial martingale conditions). Consider a family
of random variables ğ‘‹1, . . . , ğ‘‹ğ‘› taking values in {0, 1}ğ‘›. We say that they sat-
isfy the ğ›¾-super-binomial martingale conditions (or, simply, the ğ›¾-martingale
conditions) if

Pr[ğ‘‹ğ‘˜ = 0 | ğ‘‹1, . . . , ğ‘‹ğ‘˜âˆ’1] â‰¥ ğ›¾, and hence
Pr[ğ‘‹ğ‘˜ = 1 | ğ‘‹1, . . . , ğ‘‹ğ‘˜âˆ’1] â‰¤ 1 âˆ’ ğ›¾.

We may naturally apply the same terminology to inï¬nite sequences of variables
taking values in {0, 1}.

Corollary 1 (Corollary of the Azumaâ€™s inequality (cf. Lemma 7 in [3])). Let
ğ‘‹1, . . . , ğ‘‹ğ‘› satisfy the ğ›¾-super-binomial martingale conditions with ğ›¾ â‰¥ 1/2.
Then, for any ğ›¿ > 0,

Pr[#0 (ğ‘‹) â‰¤ (1 âˆ’ ğ›¿)ğ›¾ğ‘›] â‰¤ exp(âˆ’ğ›¿2ğ‘›/2)

and

Pr[#1(ğ‘‹) â‰¥ (1 + ğ›¿)(1 âˆ’ ğ›¾)ğ‘›] â‰¤ exp(âˆ’ğ›¿2ğ‘›/2)

where, #0(ğ‘‹) = |{ğ‘– |ğ‘‹ğ‘– = 0}| and #1 (ğ‘‹) = |{ğ‘– |ğ‘‹ğ‘– = 1}|.

7.6.2 The Proofs

Like in Ouroboros Praos and Ouroboros Genesis, much of the analysis on char-
acteristic strings is done by transforming them to their synchronous versions
and analyzing the latter. The resulting distribution is called the â€˜induced distri-
butionâ€™, denoted by ğœŒğ›¥(Â·). In Lemma 6 of Genesis, it is shown that the induced
distribution is a preï¬x of a distribution that satisï¬es ğ›¾(1âˆ’ ğ‘“ ) ğ›¥+1-martingale con-
ditions (cf. Deï¬nition 3). In the following, we prove certain useful properties
about the distribution which is employed in the crux of our main proof.

Deï¬nition 3 (The super-binomial martingale conditions). Consider a family
of random variables ğ‘‹1, . . . , ğ‘‹ğ‘› taking values in {0, 1}ğ‘›. We say that they sat-
isfy the ğ›¾-super-binomial martingale conditions (or, simply, the ğ›¾-martingale
conditions) if

Pr[ğ‘‹ğ‘˜ = 0 | ğ‘‹1, . . . , ğ‘‹ğ‘˜âˆ’1] â‰¥ ğ›¾, and hence
Pr[ğ‘‹ğ‘˜ = 1 | ğ‘‹1, . . . , ğ‘‹ğ‘˜âˆ’1] â‰¤ 1 âˆ’ ğ›¾.

We may naturally apply the same terminology to inï¬nite sequences of variables
taking values in {0, 1}.

34

Lemma 2 (Structure of the induced distribution). Let ğ‘Š = ğ‘Š1, . . . , ğ‘Šğ‘› be a
sequence of random variables, each taking values in {0, 1, âŠ¥}, which satisfy the
( ğ‘“ ; ğ›¾)-characteristic conditions and let

ğ‘‹ = ğ‘‹1, . . . , ğ‘‹â„“ = ğœŒğ›¥(ğ‘Š1, . . . , ğ‘Šğ‘›)

be the synchronous equivalent random variables obtained by applying the ğ›¥-
reduction mapping to ğ‘Š. Also, let Pr[ğ‘Šğ‘– =âŠ¥ |ğ‘Š1, . . . , ğ‘Šğ‘–âˆ’1] â‰¤ (1 âˆ’ ğ‘).
If
ğ›¾(1 âˆ’ ğ‘“ ) ğ›¥+1 â‰¥ (1 + ğœ–)/2 for some ğœ– â‰¥ 0 then, the following hold.

1. For any ğ›¿â„“, ğ›¿0 > 0,

ğœ–#0 (ğ‘, ğ‘›) (cid:52)

= Pr[#0 (ğ‘‹) < (1 âˆ’ ğ›¿0)

(cid:32)

â‰¤ exp

âˆ’

(cid:33)

â„“ ğ‘2ğ‘›
ğ›¿2
2(1 âˆ’ ğ‘)2

2. For any ğ›¿1 > 0,

(1 + ğœ–)
2
(cid:18)

+ exp

âˆ’

((1 âˆ’ ğ›¿â„“)ğ‘ğ‘›) âˆ’ ğ›¥]

0 ((1 âˆ’ ğ›¿â„“)ğ‘ğ‘›)
ğ›¿2
2

(cid:19)

(4)

ğœ–#1 (ğ‘, ğ‘›) (cid:52)

= Pr[#1 (ğ‘‹) > (1 + ğ›¿1)
ğ›¿2
1
2

â‰¤= exp

ğ‘ğ‘›

âˆ’

(cid:19)

(cid:18)

(1 âˆ’ ğœ–)
2

ğ‘ğ‘› âˆ’ ğ›¥]

(5)

Proof. We establish the bounds by employing Corollary 1. Recall that Corol-
lary 1 provides bounds on the number of ones and zeros in a sequence of binary
random variables that satisfy the martingale conditions. However, ğ‘Š might
contain âŠ¥ also. Therefore, we consider the ğ›¥-reduced mapping of ğ‘Š: namely,
ğ‘‹ = ğ‘‹1, . . . , ğ‘‹â„“ = ğœŒğ›¥(ğ‘Š1, . . . , ğ‘Šğ‘›) and apply the Lemma on the mapped distri-
bution.

From Lemma 8 (i) and (ii) in Ouroboros Genesis, we have that ğ‘‹1, . . . , ğ‘‹â„“âˆ’ğ›¥ is
a preï¬x to a sequence of random variables ğ‘1, ğ‘2, . . . that satisfy the ğ›¾(1âˆ’ ğ‘“ ) ğ›¥+1-
martingale conditions (for deï¬nition, see Appendix 7.6.1). Therefore, we can
apply Lemma 1 on ğ‘‹1, . . . , ğ‘‹â„“âˆ’ğ›¥.

Proof of (i). The proof of (i) is structured as follows. We will ï¬rst establish
a lower bound on â„“ by applying the Azumaâ€™s inequality. Then, for this lower
bound, we will apply Lemma 1 on ğ‘‹1, . . . , ğ‘‹â„“âˆ’ğ›¥ to obtain a lower bound on the
number of zeroes.

Consider the random variables

(cid:40)

ğ´ğ‘–

(cid:52)
=

0, if ğ‘Šğ‘– =âŠ¥
1, if ğ‘Šğ‘– â‰ âŠ¥

35

and let â„“ = (cid:205)ğ‘›
ğ‘–=1
inequality to the random variables ğµğ‘¡

ğ´ğ‘–. Then, Pr[ ğ´ğ‘– = 1 | ğ´1, . . . , ğ´ğ‘–âˆ’1] â‰¥ ğ‘. By applying Azumaâ€™s

(cid:52)
= (cid:205)ğ‘¡

ğ‘–=1( ğ´ğ‘– âˆ’ ğ‘), we obtain

Pr[â„“ < (1 âˆ’ ğ›¿â„“)ğ‘ğ‘›] â‰¤ exp

âˆ’

(cid:32)

(cid:33)

â„“ ğ‘2ğ‘›
ğ›¿2
2(1 âˆ’ ğ‘)2

(cid:32)

â‰¤ exp

âˆ’

(cid:33)

â„“ ğ‘2ğ‘›
ğ›¿2
2

(6)

With this length bound established, we must have #0(ğ‘‹) â‰¥ #0 (ğ‘1, . . . , ğ‘â„“) âˆ’

ğ›¥. Applying Lemma 1 to ğ‘ğ‘–, we conclude that

Pr[#0(ğ‘1, . . . , ğ‘â„“) â‰¤ (1 âˆ’ ğ›¿0)

(1 + ğœ–)
2

â„“] â‰¤ exp

â„“

(cid:19)

(cid:18)

âˆ’

ğ›¿2
0
2

(7)

Taking the union bound over these two bad events yields Equation (4).

Proof of (ii). By assuming the worst case of â„“ = ğ‘ğ‘› and applying Lemma 1
to the preï¬x of ğ‘ğ‘–s, we immediately obtain (5).

(cid:3)

Theorem 2. Consider the protocol Ouroboros-Samasika using maxvalid-sc
as described in Figure 7, executed in the FN-MC-registration. Let ğ‘“ be the
active-slot coeï¬ƒcient, let ğ›¥ be the upper bound on the network delay. Let
ğ›¼, ğ›½ âˆˆ [0, 1] denote a lower bound on the alert ratio and participating ratio
throughout the whole execution, respectively. Let ğ‘… and ğ¿ denote the epoch
length and the total lifetime of the system (in slots). If for some ğœ–ğ‘¤ âˆˆ (0, 1) we
have ğ›¼ Â· (1 âˆ’ ğ‘“ ) ğ›¥+1 â‰¥ (1 + ğœ–ğ‘¤ )/2 and if the maxvalid-sc parameters, ğœ–ğ‘¤ , ğ‘ CG, ğ‘ âˆƒCQ
and the network parameter ğ›¥ satisfy

288ğ›¥/(ğœ– ğ›½) < ğ‘˜, 2(1 + ğœ–ğ‘¤ )ğ‘ CG + ğ›¥ â‰¤ ğ‘…/3 and ğ‘ CG + ğ‘ âˆƒCQ â‰¤ ğ‘…/3,

then the following guarantees for common preï¬x, chain growth, chain quality,
and existential chain quality hold except for an additional error probability

exp(ln ğ¿ âˆ’ ğ›º(ğ‘˜)) + ğœ–#0 (ğ›½ ğ‘“ , Ï‰) + ğœ–#1 (ğ›½ ğ‘“ , Ï‰)
ğœ–CG (ğ›½ ğ‘“ /16, ğ‘ CG) + ğœ– âˆƒCQ (ğ‘ âˆƒCQ) + ğœ–CP (ğ‘ CG)

â€¢ Common preï¬x. The probability that the protocol violates the common

preï¬x property with parameter ğ‘˜ is no more than

ğœ–CP (ğ‘˜) (cid:52)
=

19ğ¿
ğœ– 4 exp( ğ›¥ âˆ’ ğœ– 4ğ‘˜/18) + ğœ–lift;

â€¢ Chain growth. The probability that the protocol violates the chain
(cid:52)
= 48ğ›¥/(ğœ– ğ›½ ğ‘“ ) and ğœCG = ğ›½ ğ‘“ /16

growth property with parameters ğ‘  â‰¥ ğ‘ CG
is no more than

ğœ–CG (ğœCG, ğ‘ ) (cid:52)
=

ğ‘ ğ¿2

2

exp(âˆ’(ğœ– ğ›½ ğ‘“ )2ğ‘ /256) + ğœ–lift;

36

â€¢ Existential chain quality. The probability that the protocol violates the
(cid:52)
= 12ğ›¥/(ğœ– ğ›½ ğ‘“ )

existential chain quality property with parameter ğ‘  â‰¥ ğ‘ âˆƒCQ
is no more than

ğœ– âˆƒCQ (ğ‘ ) (cid:52)

= (ğ‘  + 1)ğ¿2 exp(âˆ’(ğœ– ğ›½ ğ‘“ )2ğ‘ /64) + ğœ–lift;

where ğœ–lift is a shorthand for the quantity
(cid:19)
(cid:20)

(cid:18)

ğœ–lift

(cid:52)
= ğ‘„ğ¿ Â·

ğ‘…3 exp

âˆ’

(ğœ– ğ›½ ğ‘“ )2ğ‘…
768

+

38ğ‘…
ğœ– 4 exp

(cid:18)

ğ›¥ âˆ’

ğœ– 4 ğ›½ ğ‘“ ğ‘…ğ‘…

(cid:19)(cid:21)

864

Proof. We begin with a high-level description of the proof. Recall that our
goal is to show that when we replace maxvalid-bg with maxvalid-sc, the overall
execution of the protocol remains the same. To see this, consider a run of the
protocol with maxvalid-bg and consider the ï¬rst slcurr an honest party discovers
a long-range fork. Let Cloc be the local chain and Ccand be the candidate chain.
We will show that maxvalid-sc will output the same chain recommendation as
maxvalid-bg with all but negligible probability. (Note that, until slcurr, the whole
execution would proceed identically if parties were using maxvalid-sc instead, as
in both the cases they would always prefer the longer of the compared chains
using the short-range fork rule.) This will then imply the full statement, as
the reasoning can be applied inductively to each of the slots where maxvalid-bg
encounters a long-range fork, throughout the whole execution.

The proof is structured as follows:

1. In Lemma 3, we will show that the Ï‰-window with lowest density in Cloc

has at least thigh number of blocks.

2. In Lemma 4 and 5, we will consider a speciï¬c Ï‰-window and establish an

upper bound on the number of blocks in Ccand in that window.

We will see that thigh > tlow thereby establishing the theorem.

Lemma 3. There exists thigh such that getMinDen(Cloc) â‰¥ thigh except with
probability ğœ–#0 (ğ›½ ğ‘“ , Ï‰).

Proof. Let wmin
getMinDen(Cloc) = |Cloc [wmin
by this protocol execution within wmin
loc .

loc denote the window in Cloc with the lowest density (i.e.,
loc ]|). Let ğ‘Š denote the characteristic string induced

Note that the number of blocks in wmin

loc is at least #0 (ğ‘Š), since ğ‘Šğ‘– = 0 means
that the corresponding slot has a uniquely alert slot leader. Therefore, it suï¬ƒces
to lower bound #0 (ğ‘Š).

From Lemma 2, by setting ğ‘ = ğ›½ ğ‘“ , we get that, for any 0 < ğ›¿â„“, ğ›¿loc < 1,

Pr[#0(ğ‘Š) â‰¤ (1 âˆ’ ğ›¿loc)

(1 + ğœ–)
2

((1 âˆ’ ğ›¿â„“) ğ›½ ğ‘“ Ï‰) âˆ’ ğ›¥] â‰¤ ğœ–#0 (ğ›½ ğ‘“ , Ï‰)

Hence, we have that thigh = (1âˆ’ğ›¿loc) (1+ğœ– )

2
thigh except with probability ğœ–#0 (ğ›½ ğ‘“ , Ï‰).

((1âˆ’ğ›¿â„“) ğ›½ ğ‘“ Ï‰)âˆ’ğ›¥ and getMinDen(Cloc) â‰¥

(cid:3)

37

Towards establishing an upper bound on the window density for Ccand, we
will ï¬rst need to establish a helper lemma (Lemma 4) that states that no honest
party holds the chain Ccand at any slot > slfork + ğ‘ CG + ğ›¥.
Lemma 4. No honest party extends Ccand at any slot later than slfork + ğ‘ CG + ğ›¥
except with probability ğœ–CG (ğ›½ ğ‘“ /16, ğ‘ CG) + ğœ– âˆƒCQ (ğ‘ âˆƒCQ) + ğœ–CP (ğ‘ CG, ğ›½ ğ‘“ /16).

Proof. At a high level, the proof is structured as follows. We will consider
two consecutive intervals of slots ğ¼growth = [slfork + 1, slfork + ğ‘ CG] and ğ¼stabilize =
[slfork + ğ‘ CG + 1, slfork + ğ‘ CG + ğ‘ âˆƒCQ]. Firstly, we will show that Cloc has a large
number of blocks in ğ¼growth by employing the chain growth property; secondly,
we will show that it has at least one honest block in ğ¼stabilize by employing the
existential chain quality property; ï¬nally, in the crux of the proof, we show
that if an honest party holds Ccand at a slot later than slfork + ğ‘ CG + ğ›¥, then it
contradicts the chain preï¬x property.

In the rest of the proof, we will assume that and

(CP) there is no ğ‘ CG ğ›½ ğ‘“ /16-CP violation,

(âˆƒCQ) there is no ğ‘ âˆƒCQ-âˆƒCQ violation, and

(CG) there is no (ğ›½ ğ‘“ /16, ğ‘ CG)-CG violation.

We observe that Cloc exhibits signiï¬cant growth over the interval ğ¼growth:

speciï¬cally, by the chain growth property established in Theorem 1 of [3],

|Cloc [ğ¼growth]| â‰¥ ğ‘ CG ğ›½ ğ‘“ /16

(8)

Furthermore, observe that Cloc possesses at least one honestly-generated block
over the interval ğ¼stabilize: speciï¬cally, since |ğ¼stabilize| = ğ‘ âˆƒCQ and by the exis-
tential chain quality property established in Theorem 1 of [3], there must exist
a slot slâˆ—

loc âˆˆ ğ¼stabilize for which the block Cloc [slâˆ—

loc] was honestly generated.

In order to establish the lemma, we observe that an honest party extending
Ccand after the slot slfork + ğ‘ CG + ğ›¥ would yield a violation of common preï¬x.
Assume for contradiction that there exists an honestly generated block in Ccand
after slfork + ğ‘ CG + ğ›¥ slots. Let that slot be denoted by slâˆ—

ğ‘¡loc = Cloc [1, slâˆ—

Let ğ´ = |Cloc [ğ¼growth]| and let ğµ = |Ccand [ğ¼growth]|. Also, consider the tines
cand].

loc] and ğ‘¡cand = Ccand [1, slâˆ—
Now, we will consider the following two cases.

cand.

Case 1: ğµ â‰¥ ğ´: Recall that there is an honest block in Cloc at slâˆ—
loc and in
Ccand at slâˆ—
cand. Therefore, ğ‘¡loc and ğ‘¡cand are viable tines. This gives rise to a
divergence of div(ğ‘¡loc, ğ‘¡cand) â‰¥ ğ´. In other words, there is a divergence violation
(or CP violation) with parameter ğ´ â‰¥ ğ‘ CG ğ›½ ğ‘“ /16 (from (8)).

38

cand]. Also, recall that slâˆ—

Case 2: ğ´ > ğµ: Recall that there exists an honestly-generated block at
Ccand [slâˆ—
> slfork + ğ‘ CG + ğ›¥. Given that the delay
of ğ›¥ has passed, the honest party that generated Ccand [slâˆ—
cand] has completely
learned Cloc [1, slfork + ğ‘ CG]. Since the honest party still extended Ccand instead
of Cloc, we have that Ë†ğµ (cid:52)
= |Ccand [slfork + 1, slâˆ—
cand]| â‰¥ ğ´. Similar to the above case,
(cid:3)
this results in divergence violation with parameter ğ´ â‰¥ ğ‘ CG ğ›½ ğ‘“ /16.

cand

Recall that getMinDen(C) outputs the minimum density of blocks over win-
dows of length w slots. Consider the window corresponding to which getMinDen
output the density. Let the slot right before the window begins be denoted
by slmin. Consider the interval ğ¼growth = (slmin, slmin + Ï‰]. By the chain growth
property established in Theorem 1 of [3] and by the assumption ğ‘¤ = 1.1

Towards establishing Lemma 5 and Lemma 3, we will employ the chain
growth and the existential chain quality properties; speciï¬cally, we will consider
two disjoint consecutive intervals of length ğ‘ CG and ğ‘ âˆƒCQ between slfork and slcurr.
For this, we need to ï¬rst show that there are at least ğ‘ CG + ğ‘ âˆƒCQ slots between
slfork and slcurr so that we can apply the properties.
Lemma 5. getMinDen(Ccand) â‰¤ tlow except with probability ğœ–#1 (ğ›½ ğ‘“ , Ï‰).

Proof. In order to establish an upper bound on the min-density for Ccand, we
will consider a speciï¬c window close to the fork and establish an upper bound
of its density. It follows that the min-density of the chain is at most the upper
bound.

We will now specify the window we will focus on. Consider the ï¬rst window

that begins after the slot slfork + ğ‘ CG + ğ›¥. Denote this window by wâˆ—

cand| â‰¤ tlow.

We will show that |wâˆ—
From Lemma 4, we have that there are no honestly-generated blocks in
Ccand after the slot slfork + ğ‘ CG + ğ›¥ except with probability ğœ–CG (ğ›½ ğ‘“ /16, ğ‘ CG) +
ğœ– âˆƒCQ (ğ‘ âˆƒCQ)+ğœ–CP (ğ‘ CG, ğ›½ ğ‘“ /16). Therefore, all the blocks in Ccand after slfork+ğ‘ CG+ ğ›¥
cand| = #1( Ë†ğ‘Š), where Ë†ğ‘Š denotes
are adversarially generated. In other words, |wâˆ—
the characteristic string induced by this protocol execution within wâˆ—

We can now employ Lemma 2, by setting ğ‘ = ğ›½ ğ‘“ , we get that, for any

cand.

cand.

0 < ğ›¿1 < 1,

Pr[#1 (ğ‘Š) > (1 + ğ›¿1)

(1 âˆ’ ğœ–)
2

ğ›½ ğ‘“ âˆ’ ğ›¥] â‰¤ ğœ–#1 (ğ›½ ğ‘“ , Ï‰)

Hence, we have that tlow = (1 + ğ›¿1) (1âˆ’ğœ– )

2

except with probability ğœ–#1 (ğ›½ ğ‘“ , Ï‰).

ğ›½ ğ‘“ âˆ’ ğ›¥ and getMinDen(Ccand) â‰¤ tlow

(cid:3)

Consistent distribution. We have considered various ranges of slots in Lemma
3, 4 and 5. It is required that all those ranges have the same the same stake
distribution and randomness to determine slot leaders throughout the ranges.

39

This is ensured by the following two constraints:

ğ‘ CG + ğ›¥ + ğœˆ + Ï‰ â‰¤ ğ‘…/3
ğ‘ CG + ğ‘ âˆƒCQ â‰¤ ğ‘…/3

These constraints correspond to those in the theorem statement, since we have
assigned Ï‰ = (1 + ğœ–ğ‘¤ )ğ‘ CG and ğœˆ = ğœ–ğ‘¤ ğ‘ CG.

To ensure slot ranges are within slfork and slcurr. Observe that we have
considered various ranges of slot positions in the above proof. It remains to en-
sure that they all lie between slfork and slcurr. Towards this, we will ï¬rst establish
a lower bound on slcurr âˆ’ slfork. Then we will illustrate example assignments to
various parameters with which the slot ranges lie within the limits.

Recall that slfork is the slot associated with the last common block of Cloc and
Ccand. Recall that by the design of the protocol (independently of the underlying
maxvalid rule), for every slot slğ‘– there is an event ğ¸ğ‘– such that, if ğ¸ğ‘– occurs, then
no valid block can be created for the slot slğ‘–. Moreover, the events ğ¸1, ğ¸2, . . .
are independent and Pr[ğ¸ğ‘–] = 1 âˆ’ ğ‘“ . Therefore, using a Chernoï¬€ bound (cf.
Appendix 7.6.1) and a union bound over the running time ğ¿ of the system,
and by using the fact that there are ğ‘˜ blocks between slfork and slcurr, we can
lower-bound the number of slots between slfork and slcurr: slcurr âˆ’ slfork â‰¥ ğ‘˜/2 ğ‘“ ,
except with error probability exp(ln ğ¿ âˆ’ ğ›º(ğ‘˜)). For the remainder of the proof,
we will assume that the execution satisï¬es slcurr: slcurr âˆ’ slfork â‰¥ ğ‘˜/2 ğ‘“ for all
pairs of slots bounding at least ğ‘˜ blocks on an honestly held chain).

The following is a potential assignment that ensures that the ranges ï¬t within
the limits. ğ‘ CG, ğ‘ âˆƒCQ = ğ‘˜/(6 ğ‘“ ). Typically, ğ›¥ (cid:28) ğ‘˜/(6 ğ‘“ ). And by setting ğœ–ğ‘¤ = 1,
we get that 2(1 + ğœ–ğ‘¤ )ğ‘ CG + ğ›¥ â‰¤ ğ‘˜/(2 ğ‘“ ). Further, by setting ğ‘ âˆƒCQ = ğ‘˜/(6 ğ‘“ ), we get
ğ‘ CG + ğ‘ âˆƒCQ â‰¤ ğ‘˜/(2 ğ‘“ ). In these assignments, we needed to assume 48ğ›¥/(ğœ– ğ›½) < ğ‘˜/6
(cid:3)
which conforms with the theorem statement.

7.7 An Eï¬ƒcient Implementation of the Short-range Fork

Rule

Recall that the short-range fork rule is simply to choose the longest chain, like
in Ouroboros Genesis. Recall that a fork is a short-range one if it is less than
ğ‘˜ blocks ago in history. A naÂ¨Ä±ve implementation of this rule is to always store
the last ğ‘˜ blocks. However, this is not eï¬ƒcient. In the following, we propose
an approach where only information about just two block needs to be stored at
any given point in time.

The idea is to maintain two checkpoints in every epoch, that can provide an
estimate on how long ago a fork has occurred. One, a â€˜start checkpointâ€™, which
is at the beginning of each epoch, and the other, a â€˜lock checkpointâ€™, which is at
the last block in the ï¬rst two-thirds of an epoch. That is, in the current epoch,
as time progresses away from the ï¬rst slot, the lock checkpoint is the last block
so far until we reach the last block in the ï¬rst two-thirds of the epoch, when
the lock checkpoint â€œfreezesâ€ at that block. These checkpoints are compared

40

for candidate chains to determine when the fork has occurred. To estimate the
fork position, we consider the following two cases.

Fork in the current epoch: We categorize this as a short-range fork. This
is because the leader selection distribution for the current epoch was al-
ready determined by the end of the ï¬rst two-thirds of the previous epoch.
Therefore, we can safely assume that the adversary has not skewed the
distribution for the current epoch and the simple longest chain rule suï¬ƒces
in this case.

Fork in the previous epoch with the same lock checkpoint: Since the lock

checkpoints for the previous epoch are the same for the candidate chains,
as noted in the previous case, the leader selection distribution is well dis-
tributed even after the fork. Hence, again, the simple longest chain rule
suï¬ƒces.

8 Experimental Results

We have implemented the Mina protocol and launched the testnet with par-
ticipation from across the world. In this section, we report the results from a
representative duration between November 12, 2019, 10 AM Paciï¬c Time Zone
and December 15, 2019, 10 AM Paciï¬c Time Zone.

8.1 The Implementation Details

The implementation is written in OCaml. The SNARK themselves are written
in a special intuitive OCaml-based language called Snarky, with a backend based
on libsnark [4]. The underlying gossip protocol is based on libp2p [1].

The incrementally-computable SNARK. Recall that the Mina protocol
is based on an incrementally-computable SNARK. The SNARK implementation
employs the parallel scan state technique from Section 6.1, where for a queue of
blocks, a tree of SNARK proofs are generated and the root proof is combined
with the proof for the blockchain prior the queue, to obtain a new proof for
the updated blockchain. The SNARK proof attesting validity of a blockchain
is called a blockchain proof and all the other proofs in the trees are called
block proofs. Recall from Section 4.1.1 that, under the hood, there are three
diï¬€erent types of proofs, namely the base proofs, the wrap proofs and the merge
proofs. In eï¬€ect, we have blockchain-base proofs, blockchain-wrap proofs, block-
base proofs, block-wrap proofs and block-merge proofs.
(Note that we do not
have blockchain-merge proofs, since the blockchain proofs are only computed
sequentially and therefore, multiple blockchain proofs are never merged.)

The consensus parameters. The Mina protocol is instantiated with the
Ouroboros Samasika consensus mechanism. We set the main consensus param-

41

Type of SNARK proof Number of constraints

block-base proof
block-wrap proof
block-merge proof
blockchain-base proof
blockchain-wrap proof

42700
34954
206388
248006
28313

Table 1: Number of constraints in the diï¬€erent proofs used for the Mina proto-
col.

eters at ğ‘˜ = 10 (the number of slots before guaranteed ï¬nality), slot duration
ğ‘…=240 s, and ğ‘“ = 0.5 (the average fraction of ï¬lled slots in an epoch).

Community members across the world participated in the testnet. Besides,

a few nodes were also run by us.

Recall that, in the Mina protocol, every node is a full node, since verifying
the entire blockchain is as simple as verifying just a short, constant-sized proof.
However, every full node can have one or more of the following roles: a prover
and a block producer.

In total, the testnet had 85 unique participants. Among them, there were
49 block producers (where, 44 of the nodes were run by the community and 5
by us) and 8 unique provers .

The block producer nodes run by us used the following instance size: â€˜c5.2xlargeâ€™.

The prover nodes run by us used the following instance size: â€˜c5.9xlargeâ€™. The
community members ran their nodes on Linux, OS X, or Windows through WSL
(Windows Subsystem for Linux).

8.2 The Results

Filled vs. unï¬lled slots. Observe that the total number of slots in the
duration of interest is 15839. Among them, 7926 slots were ï¬lled. Recall that
ğ‘“ = 0.5 implied that the expect fraction of ï¬lled slots is 0.5. In the experiment,
0.5004 fraction of slots were ï¬lled.

Transactions and SNARK proofs. A total of 24826 transactions were sent,
17256 of which were from the community members. There were 78 unique
senders and 183 unique receivers.
In total, 53120 block SNARK proofs were
generated.

The ï¬gures 17, 18 and 19 report the number of daily transactions, number

of daily blocks produced and number of daily SNARKs produced.

42

Figure 17: Transactions produced from November 12, 2019, 10 AM to December
15, 2019, 10 AM, Paciï¬c Time Zone

Figure 18: Blocks produced from November 12, 2019, 10 AM to December 15,
2019, 10 AM, Paciï¬c Time Zone

Figure 19: SNARKs produced from November 12, 2019, 10 AM to December
15, 2019, 10 AM, Paciï¬c Time Zone

9 Future Work

While the presented description of the Mina protocol is for the payments sytem,
the notion can be easily extended to any Turing-complete functionalities. For

43

example, the framework can be extended to support user-deï¬ned tokens and
multisignature accounts. Also, our roadmap includes upgrading the underlying
SNARKs to the recent advances in the SNARK line of research, such as, those
with universal setup [9, 10].

10 Related Work

Mina is, of course, not the only project working on solutions to the tradeoï¬€
between scaling and decentralization. Indeed, this tradeoï¬€ has been a key chal-
lenge since the very beginning of blockchains. The very ï¬rst reply to the original
post of the bitcoin whitepaper raised this issue [13].

Since then, many solutions have been suggested, all with various tradeoï¬€s
[2]. These solutions can be categorized into those that leverage existing chains,
and those, like Mina, that propose novel architectures.

10.1 Existing Chain Solutions

The Lightning and Plasma networks move transactions oï¬€ the main chain to
side channels. However, chain operations still require downloading the entire
blockchain and suï¬€er from unsolved routing challenges [22]. There have also
been critical attacks on Lightning that limit its usefulness [21].

Light nodes have been suggested as a possible solution to enable wider ac-
cess to cryptocurrencies. They work by downloading block headers in order to
determine the Merkle root of the database state that has the strongest protocol
state.

Sharding has also been suggested as a way to increase capacity. Nodes
however have full certainty only over shards they possess the full data for. In
the case of shards that nodes do not have the full data for, those nodes essentially
have to trust the consensus nodes, and in so doing are operating as light nodes.
Furthermore, this technique suï¬€ers from the high cost of having to download a
new shard in every validator rotation [20].

Another proposed solution to blockchain access is reliance on third-party
nodes. Instead of connecting to the blockchain trustlessly, a third-party oper-
ates a full node which is relied upon for state updates. Inherently, this approach
requires trusting the third party. Such access precludes both censorship resis-
tance and guaranteed liveness.

Acknowledgement

We thank Amit Sahai for his valuable comments.

44

References

[1] libp2p: Modular peer-to-peer networking stack. [Online; accessed February

15, 2020].

[2] Vitalik Buterin talks scalability: â€˜Ethereum blockchain is almost fullâ€™, 2019

(accessed October, 2019). https://cointelegraph.com/news.

[3] Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and
Vassilis Zikas. Ouroboros genesis: Composable proof-of-stake blockchains
with dynamic availability. Cryptology ePrint Archive, Report 2018/378,
2018. â€œhttps://eprint.iacr.org/2018/378â€.

[4] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Shaul Kï¬r, Eran
Tromer, Madars Virza, and Howard Wu. libsnark. https://github.com/
scipr-lab/libsnark, 2017.

[5] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scal-
able zero knowledge via cycles of elliptic curves. In CRYPTO (2), volume
8617 of Lecture Notes in Computer Science, pages 276â€“294. Springer, 2014.

[6] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scal-
able zero knowledge via cycles of elliptic curves. Algorithmica, 79(4):1102â€“
1160, Dec 2017.

[7] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive
composition and bootstrapping for SNARKS and proof-carrying data. In
STOC, pages 111â€“120. ACM, 2013.

[8] Sean Bowe and Ariel Gabizon. Making grothâ€™s zk-snark simulation ex-
tractable in the random oracle model. Cryptology ePrint Archive, Report
2018/187, 2018. https://eprint.iacr.org/2018/187.

[9] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof compo-
sition without a trusted setup. IACR Cryptology ePrint Archive, 2019:1021,
2019.

[10] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah
Vesely, and Nicholas P. Ward. Marlin: Preprocessing zksnarks with uni-
versal and updatable SRS. IACR Cryptology ePrint Archive, 2019:1047,
2019.

[11] Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Robustly reconï¬g-
urable consensus and applications to provably secure proof of stake.
In
Financial Cryptography, volume 11598 of Lecture Notes in Computer Sci-
ence, pages 23â€“41. Springer, 2019.

[12] Bernardo David, Peter GaË‡zi, Aggelos Kiayias, and Alexander Russell.
Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake
protocol. Cryptology ePrint Archive, Report 2017/573, 2017.
http:
//eprint.iacr.org/2017/573.

45

[13] James A. Donald. Bitcoin P2P e-cash paper, 2008 (accessed October, 2019).

[14] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin back-
bone protocol: Analysis and applications. In EUROCRYPT (2), volume
9057 of Lecture Notes in Computer Science, pages 281â€“310. Springer, 2015.

[15] Jens Groth and Mary Maller. Snarky signatures: Minimal signatures of
knowledge from simulation-extractable snarks. In CRYPTO (2), volume
10402 of Lecture Notes in Computer Science, pages 581â€“612. Springer, 2017.

[16] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman
Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain proto-
col. In CRYPTO (1), volume 10401 of Lecture Notes in Computer Science,
pages 357â€“388. Springer, 2017.

[17] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cam-

bridge University Press, New York, NY, USA, 1995.

[18] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system,â€

http://bitcoin.org/bitcoin.pdf, 2008.

[19] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian
Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anony-
mous payments from bitcoin. In 2014 IEEE Symposium on Security and
Privacy, pages 459â€“474. IEEE, 2014.

[20] Alexander Skidanov. Unsolved Problems in Blockchain Sharding, 2018 (ac-

cessed October, 2019). https://medium.com/nearprotocol.

[21] Saar Tochner, Stefan Schmid, and Aviv Zohar. Hijacking routes in payment
channel networks: A predictability tradeoï¬€. CoRR, abs/1909.06890, 2019.

[22] Trustnodes. Lightning Network Has Many Routing Problems Says Lead
Dev at Lightning Labs, 2019 (accessed October, 2019). https://www.
trustnodes.com.

[23] Paul Valiant. Incrementally veriï¬able computation or proofs of knowledge
In TCC, volume 4948 of Lecture Notes in

imply time/space eï¬ƒciency.
Computer Science, pages 1â€“18. Springer, 2008.

[24] Gavin Wood et al. Ethereum: A secure decentralised generalised transac-

tion ledger. Ethereum project yellow paper, 151(2014):1â€“32, 2014.

Appendix A Chain Selection in Ouroboros Gen-

esis

Here, we recall the chain selection rule of Ouroboros Genesis. The protocol
SelectChain is the same as in Ouroboros Samasika, except for calling the algo-
rithm maxvalid-bg instead of maxvalid-sc. The algorithm maxvalid-bg is recalled
below.

46

Algorithm maxvalid-bg(Cloc, N = {C1, . . . , Cğ‘€ }, ğ‘˜, ğ‘ )

// Compare Cloc with each candidate chain in N

1. Set Cmax â† Cloc

2. for ğ‘– = 1, . . . , ğ‘€ do

if (Cğ‘– forks from Cmax at most ğ‘˜ blocks ago) then // The case of

a short-range fork

if |Cğ‘– | > |Cmax| then
Set Cmax â† Cğ‘–

end if

else // The case of a long-range fork

Let ğ‘— â† max{ ğ‘— (cid:48) â‰¥ 0 | Cmax and Cğ‘– have the same block in sl ğ‘—(cid:48)}
if getLocalForkDen(Cğ‘–, ğ‘— + ğ‘ ) > getLocalForkDen(Cmax, ğ‘— + ğ‘ )

then

Set Cmax â† Cğ‘–

end if

end if end for

3. Return Cmax

Figure 20: The chain selection rule of Ouroboros Genesis.

Algorithm getLocalForkDen(C, ğ‘›)

return |C[sl1, slğ‘›]|, the number of blocks in the ï¬rst ğ‘› slots of C.

Figure 21: The algorithm for parties to obtain chain density until a slot local
to the fork.

47

