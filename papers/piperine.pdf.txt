Replicated state machines without replicated execution

Jonathan Lee

Kirill Nikitin(cid:2)

Srinath Setty

Microsoft Research

(cid:2)EPFL

Abstract

This paper introduces a new approach to reduce end-to-end
costs in large-scale replicated systems built under a Byzantine
fault model. Speciﬁcally, our approach transforms a given
replicated state machine (RSM) to another RSM where nodes
incur lower costs by delegating state machine execution: an
untrusted prover produces succinct cryptographic proofs of
correct state transitions along with state changes, which nodes
in the transformed RSM verify and apply respectively.

To realize our approach, we build Piperine, a system that
makes the proof machinery proﬁtable in the context of RSMs.
Speciﬁcally, Piperine reduces the costs of both proving and
verifying the correctness of state machine execution while
retaining liveness—a distinctive requirement in the context of
RSMs. Our experimental evaluation demonstrates that, for a
payment service, employing Piperine is more proﬁtable than
naive reexecution of transactions as long as there are > 104
nodes. When we apply Piperine to ERC-20 transactions in
Ethereum (a real-world RSM with up to 105 nodes), it reduces
per-transaction costs by 5.4× and network costs by 2.7×.

1

Introduction

A modern example of a large-scale replicated system is a
blockchain network [64, 86], which employs replication to
enable mutually-distrusting entities to transact without rely-
ing on trusted authorities. Speciﬁcally, blockchains instantiate
replicated state machines (RSMs) [71] under a Byzantine
fault model in an open, permissionless network where each
node executes and validates every transaction. Unfortunately,
the most popular blockchains achieve a throughput of only
a handful of transactions per second. This has motivated re-
search to improve throughput and to reduce costs, for example,
by changing the underlying consensus protocol used to real-
ize RSMs [41, 46, 50]. These proposals, however, introduce
additional assumptions for safety and/or liveness (§7).

We consider a different approach, one that applies to any
existing replicated state machine in a Byzantine fault model
(including blockchains) without any changes to the underlying
consensus protocol. Naturally, it does not introduce any strong
assumptions for safety or liveness. In fact, this approach is
complementary to aforementioned advances [41, 46, 50] and
can be used in conjunction with those proposals. Our ap-
proach is based on work in the area of proof-based veriﬁable
computation (see [83] for a survey), which has developed a
powerful primitive called veriﬁable state machines [24, 73]:
for a state machine S and a batch of transactions x, an un-
trusted prover can produce outputs y and a short proof π
such that a veriﬁer can check if y is the correct output of

S with x as input (using π)—without reexecuting the state
transitions. Furthermore, the cost of verifying such a proof is
less than reexecuting the corresponding state transitions and
the size of the proof is far less than the size of the original
batch of transactions. Thus, nodes (in an RSM) that replicate
a state machine S can delegate S to an untrusted prover and
then replicate the veriﬁer at each node to verify the prover’s
proofs. Naturally, if the end-to-end resource costs of the trans-
formed RSM (CPU, storage, network, etc.) is cheaper than
the original RSM, veriﬁable delegation leads to lower costs.
In theory, the above picture is straightforward and offers
a principled solution to reduce end-to-end costs of a repli-
cated system. However, in practice, the above approach is
completely impractical. Speciﬁcally, even with state-of-the-
art systems for veriﬁable outsourcing, the veriﬁer is more
resource-efﬁcient compared to reexecution only under narrow
regimes [80, 81, 83]. Furthermore, in the context of RSMs,
the veriﬁer running at each node must have a copy of the del-
egated state machine’s state, otherwise liveness of the trans-
formed RSM hinges on the liveness of the prover (relying on
the prover for liveness introduces attack vectors for mount-
ing denial of service). Finally, the prover’s cost to produce a
proof is 104–107× higher than natively executing the corre-
sponding state transition (the overheads depends on whether
the outsourced computation is efﬁciently representable in the
computational model of the proof machinery) [73, 81].

The primary contribution of this paper is a set of techniques
to reduce the costs of veriﬁable state machines in the con-
text of RSMs and to ensure liveness without increasing the
costs of the prover. To demonstrate the beneﬁts of these tech-
niques, we build a system called Piperine. When we apply
Piperine to a popular type of state machine on Ethereum’s
blockchain, Piperine’s proofs act as compressed information
(e.g., there is no need to transmit digital signatures or the raw
transactions over the blockchain), which allows Piperine to
transparently reduce per-transaction network costs by 2.7×
and per-transaction end-to-end costs by 5.4×. Beyond cost re-
ductions, Piperine resolves an open question in the context of
replicated systems: Piperine offers the ﬁrst approach to build
RSMs with concurrent transaction processing in a permis-
sionless model. Note that prior works that achieve concurrent
transaction processing in RSMs [9, 49] require substantial
changes to the underlying consensus protocol and apply only
to a permissioned membership model.

Reducing costs. To tame costs imposed by the proof machin-
ery, Piperine leverages the following observations: (1) in our
target state machines, the primary computational bottleneck
of a state transition is authenticating a transaction by verify-

ing a digital signature; and (2) in the context of blockchains
(and RSMs that favor throughput over latency), there is signif-
icant opportunity for processing transactions in batches. The
ﬁrst observation enables Piperine to substantially drive down
end-to-end costs of the prover by aggressively optimizing the
signature veriﬁcation operation in the proof machinery (i.e.,
verifying a signature with a smaller circuit). Our optimizations
include a careful choice of cryptographic primitives as well
as several low-level cryptographic engineering techniques
such as double-scalar multiplication, windowing, efﬁcient big
number arithmetic, etc.1 Due to the second observation, the
prover can produce a single proof for a batch of transactions,
and the veriﬁer incurs a near-constant cost to verify that proof.
To drive down the veriﬁer’s costs further, Piperine employs
techniques from delegating state [24, 35, 43]—even when not
delegating state—to replace expensive modular exponentia-
tions with inexpensive hash operations.

Achieving liveness. To achieve liveness, the veriﬁer must
efﬁciently receive and verify state changes from the prover—
without trusting the prover. In the context of blockchains,
such liveness is critical: without liveness, a malicious prover
can prevent certain (or all) transactions from being executed.
Unfortunately, with prior state-of-the-art in veriﬁable state ma-
chines, the veriﬁer’s cost to receive and verify state changes
is proportional to the size of the entire state of the prover,
making the whole approach infeasible. Piperine addresses
this with new techniques. Speciﬁcally, we observe that the
veriﬁer can verify purported state changes during an epoch (a
time period where a prover executes a batch of transactions)
as long as it retains the digest of the prover’s state both at the
beginning and the end of an epoch. The computational cost
of this process to the veriﬁer is proportional to the number of
state changes within the epoch, which is theoretically optimal.

Implementation and evaluation. We implement Piperine
atop Spice [73], inheriting an end-to-end compiler toolchain:
A programmer can express a state machine in a broad subset
of C and compile it into a prover and a veriﬁer, with the prover
designed to run on a distributed cluster. We also extend the
compiler toolchain to produce a veriﬁer in Solidity, a lan-
guage for writing state machines that run on Ethereum. Using
the toolchain, we implement a blockchain-based payment ser-
vice with a standardized interface [79]. We then evaluate this
artifact using workloads modeled after real-world traces. We
ﬁnd that Piperine reduces end-to-end costs of a transaction by
5.4× and network costs by 2.7× (§6.3). Whilst Piperine does
not directly reduce mining costs of Ethereum, Piperine exe-
cutes more transactions per block, and so effectively reduces
per-transaction mining (and associated energy) costs.

Finally, we believe this work represents the ﬁrst large-scale
application of cryptographic proof machinery, and, to the

1Such optimizations are widely used for code running on standard hardware,
but it is non-trivial to realize them in the computational model of the proof
machinery, which is clumsy from a programmability perspective.

best of our knowledge, describes the ﬁrst instance in which
veriﬁably delegating computation improves the performance
of a large-scale distributed system.

2 Piperine’s base machinery

This section describes machinery that Piperine employs: veriﬁ-
able state machines [73], a primitive that involves two entities,
a prover P and a veriﬁer V, and a state machine S. It enables
the following setup. V and P agree on a non-deterministic
state machine M = (Ψ, S0), where Ψ is a program that en-
codes state transitions and S0 is the initial state of the machine.
Both V and P are given as inputs auxiliary setup material pp
related to Ψ. The internal state of P is S, which is initialized
to S0, and the internal state of V is d, which is initialized to
H(S0), where H is a collision-resistant hash function.
• P executes a state transition using input x and non-
deterministic choices w for M to produce an output y
and an updated state:

(y, S (cid:2)) ← Ψ(x, w, S) ;

S ← S (cid:2)

P sends (x, y, π, d(cid:2)) to V , where π is a proof, d(cid:2) = H(S (cid:2)).
• V runs a local check using (pp, x, y, π, d, d(cid:2)) that outputs

b ∈ {0, 1}; if b = 1, V sets d ← d(cid:2), else it aborts.

A veriﬁable state machine is a succinct non-interactive argu-
ment of knowledge [21, 45] for the language of state machine
transitions. Informally, it offers the following guarantees un-
der a set of cryptographic hardness assumptions.

• Completeness. If y is the correct output of transitioning
M with input x, some non-deterministic choices w, and d(cid:2)
is the correct digest of the updated state, P can produce a
tuple (x, y, π, d(cid:2)) such that V updates its internal state to d(cid:2).
• Knowledge soundness. If P produces a tuple (x, y, π, d(cid:2))
that makes V update its internal state from d to d(cid:2), then
there exists a PPT algorithm, called an extractor, that, with
oracle access to P, can output (w, S, S (cid:2)) such that (y, S (cid:2)) =
Ψ(x, w, S) ∧ H(S (cid:2)) = d(cid:2) ∧ H(S) = d.

• Efﬁciency. The CPU cost of verifying π is lower than the

cost of executing M’s state transitions.

APIs and programming model. In Spice [73], Ψ is ex-
pressed in a broad subset of C, which includes functions,
structs, typedefs, preprocessor macros, if-else statements,
loops (with static bounds), explicit type conversions, and
standard integer and bitwise operations. For Ψ to interact
with persistent storage, Spice offers: (1) a block store with
GetBlock/PutBlock APIs; and (2) a key-value store with a
standard get/put interface and concurrency control primi-
tives (e.g., lock/unlock) and simple transactions.

The prover runs multiple instances of Ψ in different threads.
Each thread processes distinct transactions and the shared
state is stored in a logically centralized key-value store. In

this context, Spice [73] guarantees sequential consistency [54]
for single-object operations (where an object is a key-value
pair) and serializability [20, 66] for multi-object transactions.

Mechanics. Spice [73] and its predecessors [15, 18, 24, 35,
67, 74–76, 81, 89] proceed in two steps. First, they reduce the
task of proving the correct execution of a state machine to the
task of proving the satisﬁability of a set of equations. Second,
the prover employs a cryptographic machinery to prove the
satisﬁability of the set of equations—by producing a proof.
The latter ensures that the veriﬁer is more resource-efﬁcient
than reexecuting state transitions.

(1) Program executions to constraints. Spice’s compiler
transforms Ψ to algebraic constraints, a model of computa-
tion where a program is represented as a system of equations
and variables take values from a ﬁnite ﬁeld Fp for a large
prime p. The compiler operates line-by-line over Ψ: loops are
unrolled and then each program statement is compiled to one
(or more) equations. The compiler ensures the following prop-
erty: the set of equations is satisﬁable—there exists a solution
(a setting of values to variables) to constraints—if and only
if the output is correct. To illustrate, consider a toy computa-
tion and its equivalent constraints (uppercase letters denote
variables and lowercase letters denote concrete values):

int incr(int x) {
int y = x + 1;
return y;

}

⎧
⎨

⎩

C =

X − x = 0
Y − (X + 1) = 0
Y − y = 0

⎫
⎬

⎭

For the above constraints, if y = x + 1, {X ← x, Y ← y}
is a solution. If y (cid:5)= x + 1, then there is no solution and the
constraint set is not satisﬁable.

(2) Proving the satisﬁability of constraints succinctly.
The prover identiﬁes a solution to the equations using input
x. Since the veriﬁer must be able to check this solution in
time sublinear in the running time of the computation, the
prover cannot simply send its solution to the veriﬁer. Instead,
Spice employs cryptographic machinery (called an argument
protocol) to encode the prover’s solution as a succinct proof
πx. This machinery is detailed at length elsewhere [15, 18,
24, 47, 67, 81, 83]. We now focus on details relevant for this
work: how does Spice encode state in constraints?

Supporting state in the constraints formalism. We begin
with Spice’s block store, which it inherits from Pantry [24].
Consider the following program that takes as input a digest
(e.g., a SHA-256 hash) and accesses the prover’s block store
using GetBlock/PutBlock APIs:

Digest increment(Digest d) {

// produces equations that check d==Hash(block)
int block = GetBlock(d);
int block’ = block + 1;
// produces equations that check d’==Hash(block’)
Digest d’ = PutBlock(block’);
return d’;

}

Spice’s compiler translates each GetBlock call to a set of

equations that check if the hash of the supplied block equals
the input digest (this requires representing a hash function as a
set of constraints). PutBlock translates to a similar set of con-
straints. Since the veriﬁer supplies digests, unless the prover
identiﬁes a hash collision (which is infeasible), the prover is
compelled to supply the correct block to each GetBlock and
supply the correct digest as the response to each PutBlock.
Key-value store. Spice supports a key-value store using
a particular type of hash function H(·) that operates on sets
and is incremental [10, 11, 32]: given a set-digest dS for a set
S, and a set W, one can efﬁciently compute a set-digest for
S∪W. Speciﬁcally, there is a constant time operation ⊕ where:
H(S ∪ W) = H(S) ⊕ H(W) = dS ⊕ H(W). In more detail,
a key-value store is encoded using two sets: a read-set RS
and a write-set WS. These sets contain (key, value, timestamp)
tuples for every operation on the store. Neither the prover nor
the veriﬁer materializes these sets in full; they only operate
on them using the corresponding digest (which we illustrate
below). Thus, the veriﬁer’s digest of the key-value store is:

struct KVDigest {

SetDigest rs; // a set-digest of RS
SetDigest ws; // a set-digest of WS

}

Example. If the key-value store is empty, rs = ws = H({}).
Suppose the prover executes a program Ψ that invokes
insert(k, v), it is forced to return an updated KVDigest such
that the following holds (this is done by translating insert
into appropriate constraints, as in the GetBlock example):
rs = H({}), ws = H({(k, v, 1)}).

Now, suppose the prover executes Ψ(cid:2) that invokes get(k),
which should return a value v and update the timestamp associ-
ated of the tuple. To explain how KVDigest is updated, there
are two cases to consider. First, suppose the prover behaves
and returns v that was previously stored by insert(k, v),
then: rs = H({(k, v, 1)}), ws = H({(k, v, 1), (k, v, 2)}).

A key invariant here is that whenever the prover maintains
the key-value store correctly, the set underneath rs is a subset
of the set underneath ws. To illustrate the invariant further,
consider the second case where the prover returns v(cid:2) (cid:5)= v (for
get(k)), then the set-digests returned by the prover will be:
rs = H({(k, v(cid:2), 1)}), ws = H({(k, v, 1), (k, v(cid:2), 2)}).

Observe that the set underneath rs is not a subset of the
set underneath ws. However, the veriﬁer cannot not detect
this (since set-digests have no structure to check the subset
property). Instead, the veriﬁer requires the prover to produce a
special proof πaudit periodically (e.g., for a sequence of inputs
x1, . . . xn) that proves the set underneath rs is a subset of the
set underneath ws. To do so, the prover’s πaudit proves:
∃{(ki, vi, tsi)} : ws (cid:9) rs = H({(ki, vi, tsi)}) ∧ ∀i, ki < ki+1,
where (cid:9) is the inverse of ⊕ (i.e., it results in removal of
elements from a set underneath the digest). This difference is
a set as the ki are distinct. An honest prover takes {(ki, vi, tsi)}
to be all key-value-timestamp tuples in its current state.

To produce πaudit, the prover incurs costs linear in the num-
ber of key-value tuples, but the linear cost is amortized over
all transactions processed within the epoch, and the proof pro-
duced by the prover is π = (πx1 , . . . , πxn , πaudit). Finally, as
an optimization atop Spice [73], we observe that the veriﬁer
only needs to track a single set-digest d = ws (cid:9) rs.

3 Design

This section describes the design of Piperine. We begin with
an overview of Piperine and then delve into its details.

Overview of Piperine. Piperine provides a generic mecha-
nism to transform a replicated state machine (RSM) R into
another RSM R(cid:2)—while retaining the safety and liveness
properties of R. To explain how Piperine realizes this trans-
formation, we start with a brief review of RSMs. Recall that
an RSM is a methodology to transform a state machine M
into a distributed computation running on a set of nodes such
that the distributed computation emulates a safe and live S
(under certain operating conditions about nodes, such as fault
thresholds, and the network connecting them).

In the context of an RSM, the safety property is that non-
faulty nodes progress through the same sequence of state
transitions; the liveness property is that non-faulty nodes can
eventually execute a state transition [55]. An RSM can have
one or more safety and liveness properties and Piperine is
oblivious to the speciﬁc properties (in other words, Piperine
simply preserves the safety and liveness properties of the
underlying RSM R in the transformed RSM R(cid:2)).

Constructing R(cid:2). To construct R(cid:2) for a given R that repli-
cates a state machine M, the high level recipe is as follows.
First, Piperine splits M into a preprocessing phase and a state
machine: the prover and the veriﬁer respectively (by employ-
ing the veriﬁable state machine primitive from Section 2).

The prover processes inputs (i.e., transactions) for S and
transforms them into inputs for the veriﬁer. The prover is fully
untrusted and maintains no private state, so the transactions
can be processed by any party on any untrusted infrastructure.
More concretely, a transaction can be processed by the client
that creates it, the RSM node that ﬁrst receives it, or a third
party; the choice is arbitrary and the choice can be made for
each transaction independently, so our transformation does
not incur any loss of decentralization. Such ﬂexibility exists
because the prover in Piperine is untrusted, by design, not
only for safety but also for liveness.

Finally, nodes in the original RSM then replicate the
veriﬁer—instead of S—using R. Thus, R(cid:2) is an RSM that
replicates the veriﬁer and processes transformed inputs and
proofs from the prover. Below, we provide an overview of
mechanics behind this instantiation and then provide intuition
for why R(cid:2) inherits any safety and liveness properties of R.

Overview of mechanics. Figure 1 summarizes the prover
and the veriﬁer machinery that Piperine uses.

In Piperine’s context, a state machine M is speciﬁed with

(Ψ, S0), where Ψ is a program that encodes state machine
transitions and S0 is the initial state of the machine. When
P is given a state S of S and a transaction x (S = S0 at
beginning of time), it produces:
• The output y, a digest d(cid:2) of the new state S (cid:2), and a proof

π = (πx, πaudit).

• A succinct representation Δ of the difference between S
and S (cid:2), and a proof πΔ that this difference is consistent
with the old and new digests d, d(cid:2).
For efﬁciency, πaudit and πΔ are produced by the prover
after processing a batch of transactions. For ease of exposition,
we include it with every transaction x (we relax this in (§3.3)).
V begins with a copy of S as well as its digest d. When V
is given as input a tuple (x, y, d(cid:2), π, Δ, πΔ) produced by the
prover, it runs the local checks of Section 2, and in addition
checks that πΔ proves that Δ represents the correct difference
between states whose digests match d, d(cid:2). If these checks pass,
V applies Δ to S to obtain S (cid:2).

Safety and liveness intuition. The veriﬁer’s initial state is
the initial state of the state machine S0 and a digest of
that state d. Since Piperine runs V as a state machine that
is replicated by RSM R and since R is safe, the veriﬁer
running at each node will only transition to a new state if
(x, y, d(cid:2), π, Δ, πΔ) pass the veriﬁer’s local checks. From the
completeness and soundness properties of the underlying ver-
iﬁable state machine, this happens only if y is a correct output
for the transaction x and d(cid:2) is the digest of the state after
executing x. Furthermore, the veriﬁer running at each node
obtains a correct copy of the updated state using Δ. Thus, R(cid:2)
is both safe and live as long as R is safe and live. The only ad-
ditional assumption in R(cid:2) compared to R is the cryptographic
hardness assumptions made by veriﬁable state machines. We
make this intuition more formal later (§3.3).

RSMs with an open membership model. In RSMs with
an open membership model such as blockchains, ensuring
liveness means that a new node joining the system must be
able to start with the initial state S0 and incrementally update
it using publicly available sequence of transformed inputs
until it reaches the up-to-date state S (cid:2). In other words, the
transformed inputs must be available to any new node as part
of the blockchain. We provide more details when we apply
Piperine to reduce per-transaction costs of Ethereum (§4).

3.1 Ensuring liveness

The usual way for nodes in RSMs to keep their state up-to-
date is to reexecute transitions on all the submitted inputs
that have been agreed upon by the replicated system. Because
nodes in Piperine avoid such reexecution, the veriﬁer running
at each node in the transformed RSM must be able to recover
a correct state S (cid:2) with a digest d(cid:2) from S and Δ. Furthermore,
this must be efﬁcient both for V and P. As we illustrate via a
series of straw-man solutions below, this is non-trivial due to

(cid:2288)

state:
(cid:2285), (cid:2296)

if (cid:2024)(cid:1876), (cid:2024)(cid:2911)(cid:2931)(cid:2914)(cid:2919)(cid:2930), (cid:2024)(cid:2940)
pass checks:
(cid:2285) ← (cid:2285) + Δ
(cid:2296) ← (cid:2296)′

(cid:1876)

(cid:2282)

Ψ

get

put

Ψaudit

state (cid:2285)′

ΨΔ
verify (cid:2296), (cid:2296)(cid:4593), Δ
consistent

Δ

(cid:1876), (cid:1877), (cid:2296)(cid:4593), (cid:2024)(cid:1876)

(cid:2024)(cid:1853)(cid:1873)(cid:1856)(cid:1861)(cid:1872)

Δ, (cid:2024)(cid:2940)

key-
value 
Store

FIGURE 1—Overview of Piperine’s proof machinery; our extensions
are depicted with dotted components. To apply this to RSMs, instead
of running a state machine, each node in an RSM runs the veriﬁer,
which veriﬁes proofs and state changes produced by an untrusted
prover who veriﬁably executes the designated state machine.

the requirements on computational efﬁciency, bandwidth re-
quirements, and a desire to execute transactions concurrently.
Straw-man #1. The prover could set Δ = S (cid:2) and have πΔ
prove that H(Δ) = d(cid:2). Collision resistance of H ensures
that S (cid:2) is correct if the digests match, and the proof shows
that the digest is computed correctly. The veriﬁer running
at each node performs checks as above, and if they pass, it
overwrites its local state with Δ. Unfortunately, this approach
incurs unacceptable network and computational costs. Having
Δ = S (cid:2) means that the prover would need to send its whole
state over the network for each batch of state transitions, and
that the veriﬁer (running at each node in an RSM) would need
to incur costs linear in the size of S (cid:2).
Straw-man #2. The prover could augment the proof πx to
output the state changes (i.e. a list of updated key-value pairs)
caused by executing the transaction x. The veriﬁer could then
apply those state changes. However, for efﬁciency, Piperine’s
base operates in a setting where it produces πaudit after execut-
ing a set of transactions (§2). As a result, the prover does not
materialize a concrete ordering of transactions, but merely
proves that one exists. So a malicious prover can violate safety
by providing a different ordering to the veriﬁer(s) than the
one it used internally. A solution is to make the prover’s exe-
cution veriﬁably deterministic, but it is not entirely clear how
to achieve this—without incurring substantial costs.

Additionally, the network trafﬁc is proportional to the sum
of the count of state changes in each transaction processed
by the prover—rather than the overall state change from S
to S (cid:2). In workloads where a part of the state is updated by
many transactions, the network trafﬁc includes each of those
changes, instead of just the ﬁnal values, which is sub-optimal.
Our solution. Piperine’s prover sets Δ to be a minimal set
of writes needed to take S to S (cid:2), and directly proves that:

∃S : d = H(S) ∧ d(cid:2) = H(Apply(S, Δ)).

Clearly, this approach is efﬁcient for V, as the number of
changes to make it to progress from S to S (cid:2) is the minimal

1: function delta(d, d(cid:2), Δ)
sum ← H({})
2:
for (k, vΔ, tΔ) in Δ do
3:
4:
5:
6:
7:

exists, vδ, tδ ← RPC(GETOLDVALUE, k)
sum ← sum ⊕ H({(k, vΔ, tΔ)})
if exists then

sum ← sum (cid:4) H({(k, vδ, tδ)})

8:

assert(sum = d(cid:2) (cid:4) d)

FIGURE 2—The description of ΨΔ, a computation that the prover
runs to prove that its purported state changes are correct.

possible. To explain how we make it efﬁcient for P to generate
this proof, it is necessary to unpack the details of how a key-
value store is supported in Spice [73].

Details. Recall that Piperine’s base machinery employs
an incremental hash function H(·) for sets to implement a
key-value store K. Let WS, RS be the sets of all writes and
reads to K at the end of the last epoch (i.e., at the time the last
πaudit was produced and veriﬁed). Note that neither the prover
nor the veriﬁer explicitly materializes these sets. A correct
prover simply maintains K’s current state S, and the veriﬁer
maintains a single set-digest d. Furthermore, at the end of an
epoch, the invariant is that S = WS − RS and H(S) = d.

Now, in the next epoch, when the prover executes a trans-
action x, it sends to the veriﬁer, as part of πx, the difference
δx = H(WSx) − H(RSx), where WSx, RSx are the set of writes
and reads required to execute x. From these, the veriﬁer com-
putes d(cid:2) = H(WS(cid:2)) (cid:9) H(RS(cid:2)) = d ⊕ δx, where WS(cid:2), RS(cid:2) are
the sets of all writes and reads after executing x.

We now make a few new observations. If the veriﬁer tracks
both d and d(cid:2), there are sets S, S(cid:2) such that H(S) = d ∧
H(S(cid:2)) = d(cid:2). Concretely, S = WS − RS and S(cid:2) = WS(cid:2) − RS(cid:2).
Deﬁne the sets A = S(cid:2) − S and B = S − S(cid:2), and observe that
S(cid:2) − S = A − B. Furthermore, observe that A is the minimal
set of writes that must be applied to S to get S (cid:2), and B is
the set of stale writes that A overwrites. This opens up the
following solution for the veriﬁer to efﬁciently receive and
verify state changes from the prover.

Piperine’s prover sets Δ = A, which is minimal (as noted
above). Furthermore, Piperine’s prover proves that ∃B, a set
writes to a subset of the state written to by A and that the
following condition holds: d(cid:2) (cid:9) d = H(A) (cid:9) H(B). Piperine’s
prover proves this efﬁciently by adapting techniques used to
efﬁciently produce πaudit. More concretely, the prover proves
the correct execution of the program, ΨΔ (depicted in Fig-
ure 2). ΨΔ takes as public input two digests of state d, d(cid:2),
and purported set of writes Δ, and takes as non-deterministic
input a set of overwritten values. It then checks that these state
changes are consistent with the updated digest. The veriﬁer
simply veriﬁes the proof of correct execution of ΨΔ (i.e., πΔ)
and applies the claimed state changes to its local state.

3.2 Reducing concrete costs

We make a number of additional changes to Piperine’s base
machinery to reduce the veriﬁer’s and prover’s costs.

Replacing exponentiations with hashing. In the proof ma-
chinery that Piperine uses (§2), the cost of verifying a proof
for a computation Ψ scales in the number of inputs and out-
puts of the computation, but not in the computation com-
plexity of Ψ. Concretely, each additional input or output re-
quires the veriﬁer to do one additional modular exponentia-
tion. There is also a ﬁxed cost of three pairing computations.
It is desirable to minimize the number of explicit inputs
and outputs that a computation has (whilst retaining safety).
We apply a prior idea [24] in our context: we observe that
GetBlock and PutBlock primitives from Section 2 enable
any block of data for which V knows a digest to be referenced
by a short cryptographically-binding name in a veriﬁable
way. Speciﬁcally, Piperine replaces the inputs and outputs of
computations with their short cryptographic digests and have
the veriﬁer separately verify the correctness of cryptographic
digests using their full inputs and outputs. Schematically,
Piperine transforms a computation y = f (x) into:

Digest f_wrapped(Digest in_d) {

x = GetBlock(in_d);
y = f(x);
return PutBlock(y);

}

P proves correct execution of fwrapped, and additionally
sends x and y to V. As part of its local checks, V ensures that
the digests passing in and out of fwrapped correspond to x, y.
For V, this replaces a multi-exponentiation of size O(|x| + |y|)
with hash operations that compute with O(|x| + |y|) data.

Choice of the hash function. The remaining question is
how to implement the hashing. Clearly, for the veriﬁer to gain,
the hash function must be cheaper than exponentiation. A
standard hash function (e.g., SHA-256) would be optimal in
this case. However, the prover must compute digests inside
constraints (as part of GetBlock), and executing a typical
hash function would incur ≈ 800 constraints per byte.

This cost is partially addressed in prior work [17, 24, 43,
73] where the GetBlock/PutBlock primitives are based on
the Ajtai’s hash function [6], which costs ≈ 10 constraints per
byte. In Piperine, we use the MiMC-based hash function [8]
(used in Spice [73] for a different purpose), which costs ≈ 5
constraints per byte.

Efﬁcient signature veriﬁcation. The cost of proof genera-
tion in Piperine’s proof machinery is primarily due to FFTs
and multi-exponentiations whose size is given by the number
of constraints. So reducing the number of constraints used to
represent a computation reduces prover costs. In our target
state machines, most constraints are used to implement cryp-
tographic operations, such as digital signature veriﬁcation.

Common digital signature algorithms compute over a group
where the discrete logarithm problem is hard. These groups in

turn require arithmetic over large ﬁnite ﬁelds. A prior idea [17,
35, 73] to make this efﬁcient is to ensure that the ﬁeld over
which digital signature is computed is the same ﬁeld used by
our algebraic constraints. Thus, we select digital signatures on
an elliptic curve over the ﬁeld Fp of our algebraic constraints.
There are, however, many elliptic curves over Fp. We
choose a Twisted Edwards curve [19] to avoid branching
when computing a point addition. This is because the con-
straints formalism necessitates executing all branches, which
increases costs. Speciﬁcally, we use the curve E : 634670x2 +
y2 = 1 + 634650x2y2, which is birationally equivalent to the
twist of the C∅C∅ curve [19, 53], of size N = |E| ≈ p/4.

We ﬁx a base point G, and construct ECDSA signatures
over E using the MiMC-based hash discussed above. A public
key is a point P ∈ E, and a signature on a message m is a
pair r, t ∈ [0, N). Verifying a signature requires computing
h := hash(m), r(cid:2)
:= (ht)P + (rt)G = t(hP + rG), and
checking that r is the x-coordinate of r(cid:2).

The most straightforward way to compute r(cid:2) is to compute
hP and rG with a double-and-add algorithm, add these points,
and then multiply by t (again with double-and-add). We now
discuss a series of optimizations. These optimizations are
somewhat standard in the context of high-speed cryptographic
libraries designed to run on a hardware platform such as x86.
Our innovation is in a careful selection and application of
those optimizations for code compiled to constraints. For
context, although the constraints formalism is as general as
x86, it has a completely different cost model for different
operations (e.g. bitwise operations are orders of magnitude
more expensive than 256-bit modular multiplications).

Optimizations. First, we combine the computation of
hP + rG into a single loop of doubling and adding one of
{0, P, G, P + G}; this optimization is called double-scalar
multiplication, a special case of multiexponentiation [62].

Second, we apply the above idea to a single scalar mul-
tiplication of a point Q; instead of repeatedly doubling and
adding one of {0, Q}, we repeatedly quadruple and add one
of {0, Q, 2Q, 3Q}. This optimization is called 2-bit window-
ing, a special case left-to-right k-ary exponentiation [62]. In
general, we can use larger windows, where the number of
possible summands becomes some 2w > 4. However, in con-
straints, one must encode the selection operation with ∼ 2w
constraints, so w > 2 does not improve further.

Our ﬁnal and most involved change is to compute ht and
rt mod N, which replaces one point multiplication with two
multiplications mod N. However, N (cid:5)= p, and since N2 (cid:14) p
this multiplication will overﬂow if performed naively. We
address this as follows. Given an x, y to multiply, there is
some a such that xy − aN ∈ [0, N). To compute this, we
express x, y, a, N in base B = 286, where each of x, y, a, N has
at most three digits. We then use long multiplication (base B)
to express the product as the sum of products of the digits,
shifted by powers of B. We collect the terms that have been
shifted by a common power of B for both xy and −aN. Each

aggregated term is in (−3B2, 3B2). So xy − aN is expressed
as a sum of values of modulus < 3B2, shifted by powers of B.
Since B2 = 2172 (cid:15) p/6, these sums can be computed
exactly modulo p. So we can combine the values (shifted by
powers of B) to ﬁnd xy − aN, checking that no overﬂow will
occur. To do this, we accumulate the most signiﬁcant parts of
the product, multiplying by powers of B only after checking
that the accumulator is below p/B.

Section 6.1 evaluates these optimizations.

Batching. The prover executes a batch of transactions and
provides a proof of correct execution for the batch as a whole.
The veriﬁer veriﬁes a single proof for the entire batch, thereby
amortizing the ﬁxed costs of veriﬁcation over the entire batch.
The prover also amortizes the linear cost of producing πaudit
and πΔ over the entire batch of transactions.

Finally, note that producing πaudit and πΔ requires comput-
ing over the entire state S and the state changes Δ. Building
on Spice [73], we structure these computations as a MapRe-
duce job where each mapper and reducer operates on ﬁxed-
sized chunk of data (this permits the use of a one-time trusted
setup for proof machinery regardless of the size of the prover’s
state; §8). However, different from Spice, Piperine’s prover
does not prove the execution of reducers, but instead the
veriﬁer executes reducers. This is because the reducer’s com-
putation (elliptic curve point additions, equality checks, etc.)
is not worthwhile to be outsourced to the prover.

3.3 Correctness proofs

Recall that safety and liveness properties are properties of se-
quences of states which, respectively, are closed under taking
preﬁxes, or can be preserved under extension [55].

Given an RSM R that replicates a state machine M, Piper-
ine constructs an RSM R(cid:2), which includes: (i) Piperine’s
prover; and (ii) R that replicates Piperine’s veriﬁer. We now
prove that any safety or liveness property that holds in R for
all state machines is preserved in R(cid:2) for all state machines—
except for an error probability of O((cid:4)), where (cid:4) is negligible
in the security parameter and is set to 1/2128 in practice. In
more detail, the veriﬁer that is replicated in R(cid:2) (say M(cid:2)) is
a state machine with state (S, d). The transition function of
M(cid:2) takes as input a tuple ((cid:5)y, d(cid:2), π, Δ, πΔ), and executes:
1. Assert(Verify(π, d, d(cid:2),(cid:5)y) ∧ Verify(πΔ, d, d(cid:2), Δ)).
2. (S, d) ← (S (cid:2), d(cid:2)) where S (cid:2) = Apply(S, Δ), output y.

Since we allow a probability O((cid:4)) of error, we can con-
dition on events of probability ≥ 1 − (cid:4). In particular, we
condition on Verify returning false if P does not possess
non-deterministic choices such that the claimed outputs cor-
rect, and the prover knowing no collisions in H(·). Then:

Verify(π, d, d(cid:2),(cid:5)y) =⇒ ∃σ ∈ Sym(n), x1, . . . xn, S0 . . . Sn :
(1)

H(S0) = d ∧ H(Sn) = d(cid:2)
∧i=1...n Ψ(Si−1, xσ(i)) = (Si, yσ(i))

Verify(πΔ, d, d(cid:2), Δ) =⇒ ∃δ : keys(δ) ⊆ keys(Δ)

∧ H(Δ) (cid:9) H(δ) = d(cid:2) (cid:9) d

(2)

Lemma 3.1. For a state machine M with transition function
Ψ and initial state S0 = S (where d = H(S)), given inputs (cid:5)x,
an honest prover can produce a tuple ((cid:5)y, d(cid:2), π, Δ, πΔ) such
that the state machine M(cid:2) with current state (S, d) transitions
to (Apply(S, Δ), d(cid:2)) and outputs (cid:5)y.

Proof. By the completeness of the underlying VSM, an hon-
est prover on inputs (cid:5)x and state S can compute the new state
S (cid:2), outputs yi, and state changes Δ such that d := H(S),
d(cid:2) := H(S (cid:2)), and π, πΔ pass their veriﬁcation checks, which
causes M(cid:2) in state (S, d) to transition to (Apply(S, Δ), d(cid:2))
and output (cid:5)y.

Lemma 3.2. If M(cid:2) is in state (S, d) with d = H(S), and
transitions to a state (S (cid:2), d(cid:2)) with outputs (cid:5)y, then with proba-
bility ≥ 1−O((cid:4)): (1) d(cid:2) = H(S (cid:2)), and (2) ∃(cid:5)x : M transitions
S → S (cid:2) on inputs (cid:5)x, outputting (cid:5)y in some order.

Proof. If M(cid:2) transitions, both Verify checks return true. So
(ignoring an O((cid:4)) probability of failure) the prover knows
σ, {xi}i=1...n, {Si}i=0...n and δ.

From the collision resistance of H(·), S = S0, Sn − S0 =
Δ − δ. Since keys(Δ) ⊇ keys(δ), Sn = Apply(S0, Δ), and
so S (cid:2) = Sn, implying d(cid:2) = H(S (cid:2)). Then from Equation 1,
M transitions S → S (cid:2) on inputs xσ(i), outputting yσ(i).
Theorem 3.1. If R maintains a safety property on M(cid:2), then
R(cid:2) maintains this safety property on M except for an error
probability of O((cid:4)).

Proof. By Lemma 3.2, M(cid:2) can only transition from (S, d) to
(S (cid:2), d(cid:2)) outputting (cid:5)y if M can have a sequence of transitions
from S to S (cid:2) outputting (cid:5)y. So any sequence of states (Si, di)
with outputs (cid:5)y of M(cid:2) projects down to a sub-sequence of a
sequence of states S with outputs (cid:5)y of M.

Taking preﬁxes of a sequence commutes with this projec-
tion. Furthermore, A is a sub-sequence of a preﬁx of B if and
only if A is a preﬁx of a sub-sequence of B. So if R maintains
some safety property on M(cid:2), then R(cid:2) preserves it on M.

Corollary 3.1. If R maintains a safety property S for all
state machines, then R(cid:2) maintains S for all state machines,
excepting an error probability O((cid:4)).

Theorem 3.2. If R applied to M maintains a liveness prop-
erty, then R(cid:2) applied to M maintains this liveness property.

Proof. Any states S of M can be extended to a state (S, d)
for M(cid:2), by setting d = H(S). If R maintains some liveness
property L on M, any sequence of states for M satisfying L
can be extended indeﬁnitely maintaining L.

A sequence of states of M(cid:2) project to a sub-sequence of
a sequence of states of M. If this sequence of states of M
satisfy L, then it may be extended by inputs (cid:5)x maintaining L.

Given inputs (cid:5)x causing M to transition from S to S (cid:2) out-
putting (cid:5)y, the prover can compute a ((cid:5)y, d(cid:2), π, Δ, πΔ) causing
M(cid:2) to transition from (S, H(S)) to (S (cid:2), H(S (cid:2))) and output
(cid:5)y (Lemma 3.1). So the sequence of states of M(cid:2) may be
extended maintaining L, and R(cid:2) maintains L.

Corollary 3.2. If R maintains a liveness property L for all
state machines, then R(cid:2) maintains L for all state machines.

4 Applying Piperine to Ethereum

We discuss how Piperine enhances Ethereum, starting with a
primer on the base system.

A primer on Ethereum. Ethereum is a blockchain network
that instantiates a large-scale RSM. In Ethereum, state con-
sists of a set of accounts, each of which possesses a balance in
a currency (ether). Optionally, each account can possess byte-
code written for the Ethereum Virtual Machine (EVM) and
internal persistent storage. Such bytecode is called a smart
contract and can be deployed to an account by a developer;
this facility can be used to implement decentralized applica-
tions such as payment services, games, auctions, etc. State
transitions (also known as transactions) in Ethereum consist
of transfers of balances between accounts, deploying new
smart contracts, and calls to methods exposed by smart con-
tracts (which in turn can make calls to other smart contracts).
Nodes in the Ethereum network reach consensus on an
append-only ledger of blocks containing transactions. The
execution of transactions is replicated across the network, i.e.,
each node executes every transaction in the ledger.

Each operation supported by the EVM is assigned a
complexity-based cost in a currency called gas, which is
derived from ether and hence fungible in USD (§6.3). For
example, the cost of executing arithmetic operations or read-
ing transaction data inside a contract is in single digits of
gas, whilst the cost of updating state or calling a contract is
many thousands of gas [86]. When a transaction invokes a
method exposed by a smart contract, the call is supplied by its
caller with some amount of gas, and each operation consumes
gas from this supply. If the execution of the smart-contract
call requires more gas than is supplied, the execution termi-
nates. This policy bounds the computational resources that
nodes in the network must expend to execute state transitions
in Ethereum; this is a key mechanism to prevent denial of
service attacks. The gas consumption of all smart contract
calls in a block is the block size, which is currently capped by
Ethereum to ≈ 8 · 106 and is routinely saturated in practice.

Enhancing Ethereum with Piperine. Piperine enhances
Ethereum at the level of an application. While the enhance-
ment requires several changes to the execution logic of the
application, these changes do not require any modiﬁcation
to the underlying Ethereum mechanisms and can be applied
transparently. Speciﬁcally, instead of specifying the applica-
tion as an on-chain smart contract, developers implement it
off-chain as a program Ψ using Piperine’s toolchain. Clients

who wish to invoke the application submit their transactions
to a Piperine prover. The prover accumulates transactions,
executes them in batches, and produces proofs that are then
sent to a veriﬁer. The veriﬁer is implemented as a smart con-
tract that runs natively on Ethereum. The veriﬁer contract is
generic to Ψ and implements the veriﬁcation of proofs, the ag-
gregation of changes to the state digests, and the veriﬁcation
of the purported state changes. As the veriﬁer keeps track of
the application state and incorporates cryptographic material
for proof veriﬁcation, it is deployed on a per-application basis.
All inputs processed by the veriﬁer are recorded on-chain
since the prover invokes the veriﬁer by submitting a regular
Ethereum transaction with these inputs as arguments.

Deployment and fault-tolerance. Recall from Section 3
that Piperine’s prover is untrusted for both safety and live-
ness. Thus, the prover can run on any untrusted infrastructure.
Furthermore, the prover has no private state, and all state
necessary to instantiate a new prover is persistently recorded
on-chain (in blockchain terms, there are no “data availability”
issues). Hence, any entity (a client, a miner, or a third-party
service) can act as a prover at any point—without requiring
coordination with any other instance of a prover that might
exist in the system.2 There can theoretically be an unlimited
number of provers per application (e.g., each miner can be-
come a prover for an application of its choice). In practice,
an efﬁcient deployment option is for the prover to be offered
as a commercial service that provides decentralized applica-
tions with reduced per-transaction costs—without giving up
the beneﬁts of decentralization. In our experiments (§6), we
deploy the prover on a cluster of machines in the cloud.

Bootstrapping and interoperability. We facilitate inter-
operability between Piperine-enhanced applications and na-
tive smart contracts. As an example, in the context of an
ERC-20 token [79], the main requirements are that clients
can bootstrap account balances by sending currency to the
smart contract, and can withdraw their funds unilaterally—
without trusting any prover. To support this, the smart contract
implementing the veriﬁer keeps a list of pending payments to
and from the Piperine-enhanced token. When clients wish to
bootstrap a balance, they use a traditional ERC-20 transaction
to send funds to the veriﬁer contract. The veriﬁer contract
adds the hash of this transaction to the list of pending pay-
ments to the token. When the prover wishes to issue currency
to an account on its state, it releases a transaction hash to the
veriﬁer, which rejects the state transition if the hash is not
present in the pending list. If not, it updates the pending list
to prevent a prover from double issuance.

Similarly, to withdraw funds, the prover executes a trans-
action that burns tokens in the Piperine-managed state and
whose public outputs direct the smart contract to approve
a token withdrawal, which can be collected by an ERC-20

2An alternate option is to obtain a snapshot of the state from another node.
In this case, if the snapshot is incorrect, proofs produced by the new prover
will not be accepted by the veriﬁer on-chain due Piperine’s safety properties.

transaction. Since any party can act as the Piperine prover, any
party can unilaterally withdraw funds by producing proofs of
execution for such a burn transaction and can then transition
state on the on-chain veriﬁer smart contract.

Status checks. Piperine’s prover sends a hash of each ex-
ecuted transaction to the chain as part of inputs to the veri-
ﬁer. As a corollary, any client (or a new prover) can check
whether some transaction has already been executed by check-
ing whether the hash of their transaction has appeared as an
input to the Piperine veriﬁer contract.

Choice of an elliptic curve. For efﬁciency, Piperine uses a
different elliptic curve for ECDSA signatures than Ethereum.
Thus, transactions generated for a Piperine-enhanced appli-
cation cannot be sent directly to the Ethereum chain.3 The
above interoperability mechanism alleviates this constraint
by enabling currency transfers from ether to per-application
tokens and vice versa. Moreover, the use of cryptographic
primitives that are friendly to proof machinery is often an
acceptable optimization in practice [4, 34, 85].

Details of the veriﬁer running as a smart contract. To
implement the logic of the veriﬁer, we need to build three
high-level primitives: a primitive to verify proofs produced by
the proof machinery, the MiMC hash function, and functions
to update set-digests with deltas. By default, the EVM
provides basic elliptic-curve point addition (150 gas) and
scalar multiplication (6,000 gas), in the form of precompiled
contracts (i.e., as libraries). Using these library operations,
we implement a primitive that can verify proofs produced
by the proof machinery. In our implementation, verifying a
single proof of a computation costs ≈ 201,000 + 6,150 · I gas
where I is a number of inputs and outputs to the computation.
Observe that the cost of verifying a proof is independent of
the complexity of the computation for which the proof is pro-
duced. Furthermore, our design limits the size of inputs and
outputs of a computation using GetBlock/PutBlock APIs,
so I is a constant in our context. However, the veriﬁer incurs
a cost linear in the number of hash operations, as it uses the
block store optimization (which, recall, replaces exponentia-
tions with hash operations). In our context, the hash function
is MiMC, which we implement using the EVM’s primitive
modulo operations along with custom assembly. The resulting
cost of a hash operation is ≈ 200 gas/byte. Our functions to
update set-digests are implemented directly with mulmod and
addmod, directly ported from the C implementation.

5

Implementation

We build Piperine atop Spice [73], which provides a compiler
from a subset of C augmented with storage primitives to
algebraic constraints. For producing succinct cryptographic
proofs, it invokes libsnark [57], an implementation of a
state-of-the-art proof machinery [47]. We extend Spice with
techniques described in Section 3 including ΨΔ, a high-speed

3The curve is deﬁned in Section 3.2, and has parameters of similar size to
Ethereum’s secp256k1, so it provides a similar security.

struct Txn {
int type;
Pk pk_c, pk_r; // Public keys: caller, recipient
int v;
int sig;

// Amount of currency
// Signature on the transaction

// Type of the transaction

// Delta to set-digest

}
struct Delta
struct Account { int balance };
static PK organiser;
// creates currency
Delta create(Txn txn) {

Delta d; Account recipient;
// Check the type of transaction and signature
assert(txn.type == CREATE);
assert(verify_sig(txn.pk_c, txn, txn.sig))
// Only the organiser can create tokens
assert(txn.pk_c == organiser)
// Lock and read account of txn.pk_c, update d
beg_txn(&d, [txn.pk_r], [&recipient]);
recipient.balance += txn.v;
// Write and unlock account, update d
end_txn(&d, [txn.pk_c], [recipient]);
return d;

}
// transfers currency between accounts
Delta transfer(Txn txn) {

Delta d; Account caller, recipient;
// Check the type of transaction and signature
assert(txn.type == TRANSFER);
assert(verify_sig(txn.pk_c, h, txn.sig))
// Lock and read account of txn.pk_c, txn.pk_r, update d
beg_txn(&d, [txn.pk_c, txn.pk_r], [&caller, &recipient]);
if (caller.balance >= txn.v && txn.v >= 0) {

caller.balance -= txn.v;
recipient.balance += txn.v;

}
// Write and unlock accounts, update d
end_txn(&d, [txn.pk_c, txn.pk_r], [caller, recipient]);
return d;

}

FIGURE 3—Pseudocode for ERC-20’s create and transfer op-
erations using Piperine’s API. We abstract details of the use of block
store and internal details of signature veriﬁcation. Other ERC-20
operations are programmed similarly.

library for signature veriﬁcation, etc. This adds about 375
SLOC to Spice. We implement the additional portions of
Piperine’s veriﬁer (§3.2; batching paragraph) in Python, along
with orchestration for execution on our cluster, in about 725
lines of Python. This code parallelizes the prover’s work
(executing transactions, producing proofs, etc.).

To demonstrate Piperine in action, we implement a pay-
ment processing service with a standardized interface (called
an ERC-20 token [79]) using 380 lines of C. Although we
implement our approach for only one contract, ERC-20 is a
popular standardized interface for contracts, whose implemen-
tations account for over 50% of transactions on Ethereum [33].
Figure 3 depicts pseudocode for various state transitions
in the payment state machine. The main transaction is the
transfer, which moves fungible tokens between two ac-
counts. To apply Piperine to Ethereum, we implement the

veriﬁer as a smart contract in Solidity, a language for writ-
ing state machines. In particular, we implement machinery
for verifying cryptographic proofs (which builds on an open-
source library [70] for elliptic curve pairings) and the MiMC
hash function in 500 lines of Solidity.

6 Evaluation

Our experimental evaluation of Piperine answers the follow-
ing questions:

1. What are the beneﬁts of Piperine’s techniques on end-to-

end costs of the prover and the veriﬁer in VSMs?

2. What are the regimes in which delegation via veriﬁable

state machines is better than local reexecution?

3. Does Piperine reduce costs in large-scale RSMs?

Methodology and baselines. We report our results in the
context of a state machine for processing payment transac-
tions (§5). To answer the ﬁrst question, we measure the impact
of our reﬁnements (described in §3) on the prover’s and veri-
ﬁer’s CPU costs. To answer the second question, we consider
a baseline state machine that executes the above state ma-
chine’s payment transactions by just authenticating them (i.e.,
it does not execute transitions in entirety, which is pessimistic
to Piperine). We implement the optimistic baseline using
libsodium [38], a high-speed cryptographic library. We re-
port the per-transaction costs in terms of CPU and network
costs for a system with and without Piperine.

To answer the last question, we compare Piperine-enhanced
Ethereum to native Ethereum, in both cases implementing the
above state machine. For this, we report end-to-end costs of
the two variants by using a uniﬁed metric (that accounts for
network, storage, and CPU costs). We also report the size of
a transaction in bytes in both cases.

Setup. We use a cluster of Azure D64s v3 instances (32
physical cores, 2.30 GHz Intel Xeon E5-2673 v4, 256 GB
RAM) running Ubuntu 18.04. We measure CPU-time for
the prover P and a veriﬁer V. We run parallel instances of
P on as many physical cores as are available, and compute
totals across all instances. We restrict the native V to a single
physical core for ease of comparison to the baselines, which
are single-threaded in each case.

To compare to the ERC-20 baseline, we run Piperine
against a private instance of the Ethereum RSM, using the
Web3 Python library [3] for interaction and the Ganache
suite [2] for deployment. We measure gas consumption of the
veriﬁer and the size in bytes of signed transactions using the
Web3 API. We measure CPU-time of the prover from the sys-
tem clock. Finally, we measure network costs by measuring
the number of bytes transmitted from Piperine’s prover to the
veriﬁer (in case of Piperine) and by measuring the number of
bytes in a raw transaction (in case of our baselines).

e
m

i
t

r
e
v
o
r
P

)
t
n
i
a
r
t
s
n
o
c

/

s
μ
(

 120

 100

 80

 60

 40

 20

 0

212

214

216

218

220

222

Number of Constraints

FIGURE 4—Proof generation costs per constraint the number of con-
straints in a computation Ψ varies. The solid curve is 1150μs/ log(n),
suggested by the n/ log(n) cost of multi-exponentiation algorithms.

6.1 Beneﬁts of Piperine’s techniques

To answer the ﬁrst question, we ﬁrst experimentally establish
that, in Piperine, the prover’s costs depend primarily on the
number of constraints. Thus, we can evaluate the beneﬁts of
our signature optimization by measuring their impact on the
number of constraints generated.

The two principal costs to generate a proof for a com-
putation with n constraints in Piperine are several multi-
exponentiations of size n in a pairing-friendly elliptic curve
and an FFT of size n over the ﬁeld of scalars [15, 18, 24,
47, 67, 81, 83]. Using standard algorithms, such a multi-
exponentiation takes O(n/ log n) time, whilst the FFT takes
O(n log n) time. For computations used in our evaluation,
we measure P’s CPU-time per constraint. Figure 4 depicts
our results that conﬁrm that P’s CPU-time scales roughly as
O(n/ log n), which is consistent with the theoretical predic-
tion that the prover is bottlenecked by multiexponentiations.
This experiment also conﬁrms the beneﬁts of our batching
optimization (§3.2) on the prover’s costs.

Effect of signature optimizations. To examine the impact
of signature optimizations in Piperine, we measure the num-
ber of constraints needed for a transfer state transition (to
transfer currency from one account to another) over the course
of several rounds of optimization. This metric is directly pro-
duced as a part of the process of compiling transfer with
our toolchain. Figure 5 depicts our results. As can be seen,
these optimizations reduce the number of constraints by up
to 1000×. Our individual techniques reduce the number of
constraints required by ≈ 2× compared to a baseline depicted
on the second line. While the latter is a modest improvement,
it directly impacts the number of replicas needed to amortize
the prover’s costs, in the context of RSMs (so any reﬁnement
to reduce the prover’s costs is valuable).

Effect of using a block store. To examine the impact of re-
placing modular exponentiations with hashing in Piperine, we
compile a state machine that performs transfer operations
at a range of batch sizes, with and without the optimization.
The batch size parameter does not impact the improvements,
so we report results for a batch size of 64 transactions. Fig-

 
 
 
naive
careful choice of cryptographic parameters
+ double-scalar multiplication
+ windowing
+ mod N arithmetic
+ limb optimization

# of constraints
> 107
20414
17080
16451
12574
11249

FIGURE 5—Cost of a transfer operation, in terms of number of
algebraic constraints, in Piperine with host of optimizations to the
signature veriﬁcation algorithm. Each line depicts an optimization
atop its prior line and the resulting number of constraints.

prover (x86)
(s / txn)

veriﬁer (x86)
(μs / txn)

veriﬁer (Eth)
(gas / txn)

w/o block store
w/ block store

0.79
0.84

107
104

13241
9301

FIGURE 6—Effects of the block store optimization on the CPU
costs of the prover and the veriﬁer (batch size is 64). The veriﬁer on
Ethereum beneﬁts signiﬁcantly while slightly increasing the prover’s
costs. The veriﬁer on x86 beneﬁts only slightly (see text).

ure 6 depicts the per-transaction CPU costs for the prover and
the veriﬁer; we also report gas required to execute the veriﬁer
running as a smart contract on Ethereum. As can be seen, for
the Ethereum veriﬁer, the costs are reduced by ≈ 3.3×, whilst
the cost for the prover does not increase substantially. The
veriﬁer on x86 does not beneﬁt from the optimization. This
is because the cost of multi-exponentiation is O(n/ log n),
whilst the cost of hashing for the block store is O(n) with a
smaller implied constant. However, for larger input sizes, we
expect the block store optimization to provide a beneﬁt.

6.2 Beneﬁts of Piperine for delegating state machines

We now assess the regimes in which it is cheaper to employ
delegation than naive reexecution in RSMs. Our focus here
is on resource costs (CPU and network costs) and cross-over
points (the number of replicas necessary to make the total
cost of the Piperine-enhanced RSM, including the prover’s
costs, to be cheaper than a baseline RSM).

We run Piperine and our baseline on a synthetic workload
of create and transfer operations, modeled on the trans-
action history of a popular ERC-20 token [25]. For Piperine,
we experiment with a range of batch sizes for transfer
and measure the per-transaction CPU costs to the prover and
the veriﬁer, and to our baseline. We also measure the size
of a transaction (in bytes) processed by the replicated state
machine under Piperine and the baseline.

CPU costs and cross-over points. Figure 7 depicts the per-
transaction CPU costs of the prover, the veriﬁer, and the
baseline for varying batch sizes. As expected, the baseline
CPU cost does not decrease with batch size whereas the
veriﬁer beneﬁts signiﬁcantly from batching. Furthermore, for
batch sizes ≥ 64 the Piperine V has lower CPU costs than

batch size
(#txns)

baseline
(μs/txn)

veriﬁer
(μs/txn)

prover
(s/txn)

cross-over
(#replicas)

1
4
16
64
256
1024

120
116
115
118
118
117

3799
931
275
107
63
42

1.34
1.02
0.88
0.79
0.78
0.75

–
–
–
68365
14280
10072

FIGURE 7—The per-transaction CPU cost of the prover, the veriﬁer,
and the baseline with varying batch sizes. We also depict cross-
over points: the number of replicas needed to make the Piperine-
enhanced RSM (including the prover’s costs) to incur lower CPU
costs than a replicated baseline. The veriﬁer beneﬁts signiﬁcantly
from batching while the prover’s gains are modest. Beyond batch
size of 64, Piperine-enhanced RSM is cheaper than the baseline.

batch size
(#txns)

baseline
(bytes)

Piperine
(bytes)

savings
(×)

1
4
16
64
256
1024

224
224
224
224
224
224

588
259
147
132
129
80

–
–
1.5
1.7
1.7
2.8

FIGURE 8—The per-transaction network costs of Piperine and the
baseline with varying batch sizes. At the largest batch size, the per-
transaction network costs to propagate a transaction to the replicated
system is 2.8× lower in Piperine than the baseline.

the baseline. At large batch sizes, the veriﬁer’s CPU costs are
lower than that of the baseline by about 2.7×. Although the
prover’s CPU costs are ≈ 6,300–11,000× higher than that
of the baseline, there exists a cross-over point (in terms of
the number of replicas in an RSM) at which the CPU cost of
the prover and the replicated veriﬁer is lower than the CPU
cost of the replicated baseline. With a batch size of 1024, the
cross-over point is about 10,000 replicas.

Network costs. Figure 8 depicts the size of a transaction
processed by the RSM in Piperine and the baseline. Beyond a
batch size of 16, Piperine always incurs lower network costs
than the baseline. This is because Piperine compresses each
transaction to a hash and a minimal speciﬁcation of its impact
on the state. At a batch size of 1024, the savings are a factor
of 2.8, which can be signiﬁcant in blockchains [36].

6.3 Beneﬁts of Piperine for large-scale RSMs

To answer the third question, we run a set of experiments
similar to the previous subsection, except that we experiment
with the Piperine veriﬁer running as a smart contract. Further-
more, instead of an optimistic baseline based on libsodium,
the baseline here is an ERC-20 smart contract [79].

End-to-end per-transaction costs in gas and USD. Be-
sides the metrics used in the last subsection (CPU costs,
network transfers, etc.), we use an additional metric—

Ethereum’s gas (§4)—that captures the end-to-end costs of
the prover and the veriﬁer in a uniﬁed manner. Although the
prover runs on a cluster of machines in the cloud and billed
in USD for the total machine cost (CPU, network, storage,
etc.), the prover’s cost can be converted to gas because gas is
fungible in USD. It might seem that this conversion must be
done with care since the exchange rate between gas and USD
is highly volatile. Since 2017, the daily average price for 106
gas has varied between $0.80 and $100, with intra-day volatil-
ity of ≥ 10×. As shown below, perhaps surprisingly, picking
any rate in the above range does not signiﬁcantly affect our
results. This is because the total cost of a Piperine-enhanced
ERC-20 contract is dominated by the veriﬁer’s gas costs, so
the prover’s costs in USD (when converted to gas) do not
substantially affect the end-to-end costs of the system. Below,
we conservatively assume an exchange rate of $1 for 106 gas.
In this experiment, the prover processes about 0.5 million
ERC-20 transfer transactions (in batches where each batch
is of size 1,100 transactions). The prover then produces a
πaudit by performing a linear scan over the entire state, which
in our workload is about ≈ 175,000 key-value tuples (i.e.,
account balances); the prover uses a chunk size of 12,288
tuples to produce πaudit in parallel (§3.2). The prover also
produces a πΔ, which in our experiment emits the entire
state (the chunk size here is 450 state changes). We pick
these parameters to reduce the prover’s and veriﬁer’s costs via
aggressive batching and to ensure that each of these proofs can
be veriﬁed with < 8·106 gas. We measure the prover’s time to
produce these proofs and state changes and then calculate the
total machine cost to run the prover. We also run the veriﬁer
as a smart contract and measure the veriﬁer’s costs, in terms
of gas, to verify these proofs and state changes.

Figure 9 depicts our results. The per-transaction gas costs
of Piperine’s veriﬁer are lower than the baseline by ≈ 5.4×.
The USD cost of Piperine’s prover is ≈ 250× smaller than
the USD cost of Piperine’s veriﬁer, so the 5.4× saving in gas
translates directly into a similar savings in USD terms.

Note that the prover’s cost to produce πaudit depends only
on the size of the state whereas the cost to process trans-
actions and to produce πΔ scale linearly in the number of
transactions. In the above experiment, πaudit is produced only
after processing 5 · 105 transactions, but on end-to-end per-
transaction costs, it accounts for only 0.09% and 0.03% of
the overall USD and network costs respectively, so producing
πaudit more frequently does not substantially affect our results.
Transaction sizes and network costs. As in the prior sub-
section, Piperine reduces the size of transactions by ≈ 2.7×.
We note that in Piperine the size of a transaction is dominated
by a single hash and the associated state changes, so it is
insensitive to the size of arguments to a smart contract’s API
or Ethereum’s digital signatures. Whereas, for an on-chain
contract in Ethereum, the size of transactions is dominated
by signatures and call arguments. Furthermore, as noted in
Section 4, Ethereum’s blocks are limited by the scarce supply

computation costs

instances
(#)
batch Ψtransfer 512
chunk Ψaudit
15
chunk ΨΔ
389

Piperine (/txn)
baseline (/txn)

prover
(s)

677.79
605.93
60.67

0.67
0

veriﬁer
(gas)

5561726
293377
6448764

9518
51668

total
(USD)

network
(bytes)

$5.6
$0.33
$6.44

0.96¢
5.17¢

35888
720
43856

62.9
170

FIGURE 9—The costs of the prover, the veriﬁer, and the baseline
along with network costs under Piperine and the baseline. As noted,
we assume 106 gas costs $1; the prover’s costs are based on a ma-
chine cost of 20.9¢/hour as reported by the cloud provider.

of gas, so Piperine’s reduction in per-transaction gas directly
translates to an increased number of transactions in each block
(improving Ethereum’s throughput). While Ethereum can
pack ≈ 150 ERC-20 transactions/block, Piperine-enhanced
ERC-20 can pack ≈ 850 transactions/block.

7 Related work

A set of works achieve higher throughput on blockchains by
changing the underlying consensus protocol, assumptions,
or guarantees. Bitcoin-NG [41] increases Bitcoin’s through-
put by using proof-of-work solely for leader election, whilst
enabling the leader to approve transactions at a higher rate.
However, this approach is vulnerable to double spending
in the short term by a non-rational malicious leader. Byz-
coin [50] strengthens Bitcoin-NG by electing a quorum of
nodes that in turn use PBFT [29], but it requires a super
majority of those elected nodes to be honest. Algorand [46]
selects a committee, as in Byzcoin, but using light-weight
veriﬁable random function, instead of proof-of-work. Un-
like Byzcoin, it assumes that the majority of currency in the
system is owned by honest nodes. The latter comes with its
own issues [42]. Instead of the randomized committee se-
lection, Arbitrum [48] allows parties to manually choose a
set of managers on a per-contract basis to monitor for cor-
rect execution. The blockchain accepts state transitions if
they are endorsed either by all the managers, or by one of
them and not disputed later. This requires active monitoring,
or trusting managers. A similar optimistic approach is fol-
lowed in other works [5, 44, 68, 78]. Other approaches for
accelerating blockchains include sharding [7, 51, 59, 84, 88],
multi-chaining [56, 77], off-chain state channels [39, 63], pay-
ment channels and networks [37, 60, 63, 69], and the use of
trusted execution environments [30, 58] (see a position pa-
per [36] for an overview). We highlight that Piperine operates
at a different level than these systems and can be used in
combination with any of them to further increase throughput
and achieve lower per-transaction costs.

Zerocash [14], Hawk [52], and Zexe [22] use proof ma-
chinery similar to Piperine’s, but they primarily focus on
privacy of transactions, rather than system scalability. Hawk

in particular relies on a manager to execute all the contract
computations and lacks mechanisms for state reconstruction,
which can lead to degraded performance and hindered live-
ness. Zerocash does not suffer from such liveness issues as it
does not rely on a manager (each user acts as a manager of
its own state) but supports only payment transactions. Zexe
extends Zerocash to support a richer model of ofﬂine com-
putation. Although, the on-chain cost of verifying a proof is
independent of the ofﬂine computation, it does not demon-
strate improved blockchain throughput or lower transaction
costs. Zether [28] offers privacy for amounts in a transaction
using commitments and range proofs. ZoKrates [40] offers
a programming toolchain similar to Piperine to support off-
blockchain computation with a veriﬁer running on Ethereum.
However, ZoKrates does not provide a veriﬁable storage prim-
itive nor guarantees liveness for off-chain state.

Unlike a traditional blockchain that increases in size over
time, Coda [61] proposes a constant-sized blockchain that
maintains a single Merkle root of the current state, using
recursive proofs [17]. Unfortunately, Coda lacks key liveness
properties: one cannot recover state or update Merkle proofs
from the blockchain information alone.

In concurrent work, StarkDEX [12] and StarkPay [23] pro-
pose a solution that is similar in spirit, yet qualitatively dif-
ferent from Piperine. In these proposals, the veriﬁer stores a
Merkle root of the state, and the prover transitions the ver-
iﬁer’s state by supplying a new Merkle root along with a
proof. This approach does not satisfy liveness as it lacks a
mechanism for an arbitrary entity to reconstruct the inter-
nal state of the system (i.e., the prover is trusted for data
availability). They allude to a future mechanism to “freeze”
the system when the prover fails, and in that circumstance,
clients can regain custody of their assets by providing suitable
Merkle proofs. However, for a client to construct such Merkle
proofs, the prover must be modiﬁed to produce a list of state
changes during transaction execution and those changes must
be persisted reliably (e.g., as in Piperine). In terms of mecha-
nisms, Piperine relies on the Groth16 proof system [47] for
proof generation and on set data structures for state, whereas
StarkDEX and StarkPay use zkSTARKs [13] and Merkle
trees, respectively. Prior performance reports [73, 82, 87]
show that both mechanisms employed by Piperine achieve
signiﬁcantly lower costs for the prover.

Unlike Stark-based proposals, Rollup [1, 26, 27, 85], an
ongoing project in the Ethereum community to build an off-
chain payment service, does not suffer from aforementioned
liveness issues. However, like Stark-based proposals, it relies
on Merkle trees as a storage primitive whereas Piperine em-
ploys set data structures; the latter enables concurrent transac-
tion processing and cheaper storage operations (§2). Based on
prior performance reports [73], this means Piperine’s prover
is cheaper than Rollup’s prover by small constant factors to
several orders of magnitude (depending on the hash function
employed by Rollup). This gap widens for state machines that

are more complex than a payment service.

Very recently, Ozdemir et al. [65] describe a new storage
primitive based on set accumulators for building veriﬁable
state machines. Unlike Piperine’s set-based storage, it does
not require the prover to produce a periodic πaudit (§2). How-
ever, with their primitive, each storage operation requires a
higher number of algebraic constraints than Piperine (small
constant factors depending on the batch size).

8 Discussion

Trusted setup. Piperine employs a proof machinery [47]
that requires a trusted setup: a trusted party must create cryp-
tographic material that depends on Ψ but not on inputs or
outputs to Ψ. Such a trusted setup can be executed by a
set of parties in a distributed protocol where at most one
party needs to be honest [16]. Designing an efﬁcient proof
machinery without trusted setup is a topic of ongoing re-
search [13, 31, 72, 82]; we plan to explore such a proof ma-
chinery in Piperine in the future.

Reducing the costs of the proof machinery further. In the
context of blockchains, we can drive down the cost of the
Piperine veriﬁer further by using an inexpensive hash function
(e.g., SHA-256). However, as discussed earlier, this increases
the prover’s costs by orders of magnitude. But, one can reduce
the prover’s monetary costs using GPU clusters, or serverless
computing, which offer cheaper computing cycles per USD.

9 Summary

We began this project with the following question: can we
reduce end-to-end costs in large-scale replicated systems by
delegating state machine executions? Our system, Piperine,
offers an afﬁrmative answer. Speciﬁcally, Piperine provides
a generic mechanism to reduce CPU and network costs of
a given RSM—under certain operating conditions about the
number of nodes and complexity of the delegated state ma-
chine. Furthermore, Piperine offers the ﬁrst mechanism to
execute transactions concurrently in an RSM built under an
open, permissionless model. Finally, Piperine demonstrates
the ﬁrst large-scale application of cryptographic proof ma-
chinery to reduce costs in a real-world system. As a result of
these, we believe this work represents progress.

Acknowledgments. We thank Sebastian Angel, Riad Wahby, and
the anonymous S&P reviewers for helpful comments that signiﬁ-
cantly improved the presentation of this work. Part of this work was
performed during Kirill Nikitin’s internship at Microsoft Research.

References
[1] Ethereum Roadmap. ZK-Rollups.

https://docs.ethhub.io/ethereum-roadmap/layer-2-
scaling/zk-rollups/.

[2] Ganache. https://truffleframework.com/ganache.
[3] Web3.py.

https://web3py.readthedocs.io/en/stable/.

[4] STARK-friendly hash challenge.

https://starkware.co/hash-challenge/, Aug. 2019.

[5] J. Adler. Minimal viable merged consensus.

https://ethresear.ch/t/minimal-viable-merged-
consensus/5617, June 2019.

[6] M. Ajtai. Generating hard instances of lattice problems

(extended abstract). In Proceedings of the ACM Symposium
on Theory of Computing (STOC), pages 99–108, 1996.

[7] M. Al-Bassam, A. Sonnino, S. Bano, D. Hrycyszyn, and

G. Danezis. Chainspace: A sharded smart contracts platform.
In Proceedings of the Network and Distributed System
Security Symposium (NDSS), 2018.

[8] M. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen.

MiMC: Efﬁcient encryption and cryptographic hashing with
minimal multiplicative complexity. In Proceedings of the
International Conference on the Theory and Application of
Cryptology and Information Security (ASIACRYPT), 2016.

[9] E. Androulaki, A. Barger, V. Bortnikov, C. Cachin,

K. Christidis, A. D. Caro, D. Enyeart, C. Ferris, G. Laventman,
Y. Manevich, S. Muralidharan, C. Murthy, B. Nguyen,
M. Sethi, G. Singh, K. Smith, A. Sorniotti, C. Stathakopoulou,
M. Vukolic, S. W. Cocco, and J. Yellick. Hyperledger fabric:
A distributed operating system for permissioned blockchains.
In Proceedings of the ACM European Conference on
Computer Systems (EuroSys), pages 30:1–30:15, 2018.

[10] A. Arasu, K. Eguro, R. Kaushik, D. Kossmann, P. Meng,
V. Pandey, and R. Ramamurthy. Concerto: A high
concurrency key-value store with integrity. In Proceedings of
the ACM International Conference on Management of Data
(SIGMOD), 2017.

[11] M. Bellare and D. Micciancio. A new paradigm for

collision-free hashing: Incrementality at reduced cost. In
Proceedings of the International Conference on the Theory
and Applications of Cryptographic Techniques
(EUROCRYPT), 1997.

[12] E. Ben-Sasson. The STARK truth about DEXes. Stanford

Blockchain Conference, 2019.

[13] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable
zero knowledge with no trusted setup. In Proceedings of the
International Cryptology Conference (CRYPTO), Aug. 2019.

[14] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers,

E. Tromer, and M. Virza. Zerocash: Decentralized anonymous
payments from Bitcoin. In Proceedings of the IEEE
Symposium on Security and Privacy (S&P), 2014.
[15] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and

M. Virza. SNARKs for C: Verifying program executions
succinctly and in zero knowledge. In Proceedings of the
International Cryptology Conference (CRYPTO), Aug. 2013.
[16] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza.
Secure sampling of public parameters for succinct zero
knowledge proofs. In Proceedings of the IEEE Symposium on
Security and Privacy (S&P), 2015.

[17] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable
zero knowledge via cycles of elliptic curves. In Proceedings
of the International Cryptology Conference (CRYPTO), 2014.
[18] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct

non-interactive zero knowledge for a von Neumann
architecture. In Proceedings of the USENIX Security
Symposium, 2014.

[19] D. J. Bernstein, P. Birkner, M. Joye, T. Lange, and C. Peters.

Twisted Edwards curves. In AFRICACRYPT, 2008.
[20] P. A. Bernstein, D. W. Shipman, and W. S. Wong. Formal
aspects of serializability in database concurrency control.
IEEE Transactions on Software Engineering, SE-5(3), May
1979.

[21] N. Bitansky, A. Chiesa, Y. Ishai, O. Paneth, and R. Ostrovsky.
Succinct non-interactive arguments via linear interactive
proofs. In Theory of Cryptography Conference, 2013.
[22] S. Bowe, A. Chiesa, M. Green, I. Miers, P. Mishra, and H. Wu.

Zexe: Enabling decentralized private computation. In
Proceedings of the IEEE Symposium on Security and Privacy
(S&P), 2020.

[23] T. Brand, U. Kolodny, and A. Levy. When lightning STARKs.
https://medium.com/starkware/when-lightning-
starks-a90819be37ba, Mar. 2019.

[24] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and

M. Walﬁsh. Verifying computations with state. In
Proceedings of the ACM Symposium on Operating Systems
Principles (SOSP), 2013.

[25] Brave Software. Basic Attention Token. https:

//basicattentiontoken.org/wp-content/uploads/
2017/05/BasicAttentionTokenWhitePaper-4.pdf, Mar.
2018.

[26] V. Buterin. On-chain scaling to potentially 500 tx/sec through
mass tx validation. https://ethresear.ch/t/on-chain-
scaling-to-potentially-500-tx-sec-through-
mass-tx-validation/3477, Sept. 2018.
[27] V. Buterin. The dawn of hybrid layer 2 protocols.

https://vitalik.ca/general/2019/08/28/hybrid_
layer_2.html, Aug. 2019.

[28] B. BÃijnz, S. Agrawal, M. Zamani, and D. Boneh. Zether:

Towards privacy in a smart contract world. Cryptology ePrint
Archive, Report 2019/191, 2019.

[29] M. Castro and B. Liskov. Practical Byzantine fault tolerance.
In Proceedings of the USENIX Symposium on Operating
Systems Design and Implementation (OSDI), pages 173–186,
1999.

[30] R. Cheng, F. Zhang, J. Kos, W. He, N. Hynes, N. Johnson,

A. Juels, A. Miller, and D. Song. Ekiden: A platform for
conﬁdentiality-preserving, trustworthy, and performant smart
contracts. In Proceedings of the IEEE European Symposium
on Security and Privacy (EuroS&P), pages 185–200, 2019.
[31] A. Chiesa, D. Ojha, and N. Spooner. Fractal: Post-quantum

and transparent recursive proofs from holography. Cryptology
ePrint Archive, Report 2019/1076, 2019.

[32] D. Clarke, S. Devadas, M. V. Dijk, B. Gassend, G. Edward,

and S. Mit. Incremental multiset hash functions and their
application to memory integrity checking. In Proceedings of
the International Conference on the Theory and Application of
Cryptology and Information Security (ASIACRYPT), 2003.

[33] CoinMetrics. State of the network: Issue 25.

https://coinmetrics.substack.com/p/coin-metrics-
state-of-the-network-44c, Nov. 2019.

[34] Z. E. C. Company. What is Jubjub?

https://z.cash/technology/jubjub.html, 2017.
[35] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter,
M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile
veriﬁable computation. In Proceedings of the IEEE

Symposium on Security and Privacy (S&P), May 2015.
[36] K. Croman, C. Decker, I. Eyal, A. E. Gencer, A. Juels,

A. Kosba, A. Miller, P. Saxena, E. Shi, E. G. Sirer, et al. On
scaling decentralized blockchains. In Proceedings of the
International Financial Cryptography and Data Security
Conference, pages 106–125, 2016.

[37] C. Decker and R. Wattenhofer. A fast and scalable payment
network with Bitcoin duplex micropayment channels. In
Symposium on Self-Stabilizing Systems, pages 3–18, 2015.

[38] F. Denis. Libsodium.

https://github.com/jedisct1/libsodium.

[39] S. Dziembowski, S. Faust, and K. Hostáková. General state

channel networks. In Proceedings of the ACM Conference on
Computer and Communications Security (CCS), pages
949–966, 2018.

[40] J. Eberhardt and S. Tai. ZoKrates – Scalable

privacy-preserving off-chain computations. In IEEE
International Conference on Blockchain, pages 1084–1091,
2018.

[41] I. Eyal, A. E. Gencer, E. G. Sirer, and R. V. Renesse.

Bitcoin-NG: A scalable blockchain protocol. In Proceedings
of the USENIX Symposium on Networked Systems Design and
Implementation (NSDI), pages 45–59, 2016.

[42] G. Fanti, L. Kogan, S. Oh, K. Ruan, P. Viswanath, and

G. Wang. Compounding of wealth in proof-of-stake
cryptocurrencies. In Proceedings of the International
Financial Cryptography and Data Security Conference, 2019.
[43] D. Fiore, C. Fournet, E. Ghosh, M. Kohlweiss, O. Ohrimenko,
and B. Parno. Hash ﬁrst, argue later: Adaptive veriﬁable
computations on outsourced data. In Proceedings of the ACM
Conference on Computer and Communications Security
(CCS), 2016.

[44] K. Floersch. Ethereum smart contracts in L2: Optimistic

Rollup.
https://medium.com/plasma-group/ethereum-smart-
contracts-in-l2-optimistic-rollup-2c1cef2ec537,
Aug. 2019.

[45] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic

span programs and succinct NIZKs without PCPs. In
Proceedings of the International Conference on the Theory
and Applications of Cryptographic Techniques
(EUROCRYPT), 2013.

[46] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich.
Algorand: Scaling Byzantine agreements for cryptocurrencies.
In Proceedings of the ACM Symposium on Operating Systems
Principles (SOSP), pages 51–68, 2017.

[47] J. Groth. On the size of pairing-based non-interactive

[50] E. Kokoris-Kogias, P. Jovanovic, N. Gailly, I. Khofﬁ,

L. Gasser, and B. Ford. Enhancing Bitcoin security and
performance with strong consistency via collective signing. In
Proceedings of the USENIX Security Symposium, pages
279–296, 2016.

[51] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta,

and B. Ford. Omniledger: A secure, scale-out, decentralized
ledger via sharding. In Proceedings of the IEEE Symposium
on Security and Privacy (S&P), pages 583–598, 2018.
[52] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou.
Hawk: The blockchain model of cryptography and
privacy-preserving smart contracts. In Proceedings of the
IEEE Symposium on Security and Privacy (S&P), pages
839–858, 2016.

[53] A. Kosba, Z. Zhao, A. Miller, Y. Qian, H. Chan,

C. Papamanthou, R. Pass, abhi shelat, and E. Shi. C∅C∅: A
framework for building composable zero-knowledge proofs.
Cryptology ePrint Archive, Report 2015/1093, 2015.
[54] L. Lamport. How to make a multiprocessor computer that

correctly executes multiprocess programs. IEEE Transactions
on Computers, C-28(9), Sept. 1979.

[55] L. Lamport. Specifying Systems: The TLA+ Language and

Tools for Hardware and Software Engineers. Addison-Wesley,
June 2002.

[56] Y. Lewenberg, Y. Sompolinsky, and A. Zohar. Inclusive block
chain protocols. In Proceedings of the International Financial
Cryptography and Data Security Conference, pages 528–547,
2015.

[57] libsnark. A C++ library for zkSNARK proofs.

https://github.com/scipr-lab/libsnark, 2012.

[58] J. Lind, O. Naor, I. Eyal, F. Kelbert, E. G. Sirer, and

P. Pietzuch. Teechain: a secure payment network with
asynchronous blockchain access. In Proceedings of the ACM
Symposium on Operating Systems Principles (SOSP), pages
63–79, 2019.

[59] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and
P. Saxena. A secure sharding protocol for open blockchains.
In Proceedings of the ACM Conference on Computer and
Communications Security (CCS), pages 17–30, 2016.
[60] P. McCorry, M. Möser, S. F. Shahandasti, and F. Hao.

Towards Bitcoin payment networks. In Proceedings of the
Australasian Conference on Information Security and Privacy,
pages 57–76, 2016.

[61] I. Meckler and E. Shapiro. Coda: Decentralized

cryptocurrency at scale.
https://cdn.codaprotocol.com/v2/static/coda-
whitepaper-05-10-2018-0.pdf, 2018.

arguments. In Proceedings of the International Conference on
the Theory and Applications of Cryptographic Techniques
(EUROCRYPT), 2016.

[62] A. J. Menezes, S. A. Vanstone, and P. C. V. Oorschot.

Handbook of Applied Cryptography. CRC Press, Inc., 1st
edition, 1996.

[48] H. Kalodner, S. Goldfeder, X. Chen, S. M. Weinberg, and

[63] A. Miller, I. Bentov, S. Bakshi, R. Kumaresan, and

E. W. Felten. Arbitrum: Scalable, private smart contracts. In
Proceedings of the USENIX Security Symposium, pages
1353–1370, 2018.

[49] M. Kapritsos, Y. Wang, V. Quema, A. Clement, L. Alvisi, and
M. Dahlin. All about Eve: Execute-Verify replication for
multi-core servers. In Proceedings of the USENIX Symposium
on Operating Systems Design and Implementation (OSDI),
pages 237–250, 2012.

P. McCorry. Sprites and state channels: Payment networks that
go faster than lightning. In Proceedings of the International
Financial Cryptography and Data Security Conference, 2019.
[64] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system,

Oct. 2008.

[65] A. Ozdemir, R. S. Wahby, and D. Boneh. Scaling veriﬁable

computation using efﬁcient set accumulators. Cryptology
ePrint Archive, Report 2019/1494, 2019.

[66] C. H. Papadimitriou. The serializability of concurrent

(S&P), 2018.

[83] M. Walﬁsh and A. J. Blumberg. Verifying computations

without reexecuting them: From theoretical possibility to near
practicality. Communications of the ACM, 58(2), Jan. 2015.

[84] J. Wang and H. Wang. Monoxide: Scale out blockchains with
asynchronous consensus zones. In Proceedings of the
USENIX Symposium on Networked Systems Design and
Implementation (NSDI), pages 95–112, 2019.
[85] B. WhiteHat, A. Gluchowski, HarryR, Y. Fu, and

P. Castonguay. Roll_up / roll_back snark side chain ~17000
tps. https://ethresear.ch/t/roll-up-roll-back-
snark-side-chain-17000-tps/3675, Oct. 2018.
[86] G. Wood. Ethereum: A secure decentralised generalised

transaction ledger Byzantium version.
https://ethereum.github.io/yellowpaper/paper.pdf,
Oct. 2019.

[87] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song.
Libra: Succinct zero-knowledge proofs with optimal prover
computation. In Proceedings of the International Cryptology
Conference (CRYPTO), 2019.

[88] M. Zamani, M. Movahedi, and M. Raykova. RapidChain:
Scaling blockchain via full sharding. In Proceedings of the
ACM Conference on Computer and Communications Security
(CCS), pages 931–948, 2018.

[89] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and

C. Papamanthou. vSQL: Verifying arbitrary SQL queries over
dynamic outsourced databases. In Proceedings of the IEEE
Symposium on Security and Privacy (S&P), 2017.

database updates. Journal of the ACM (JACM), 26(4), Oct.
1979.

[67] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio:
Nearly practical veriﬁable computation. In Proceedings of the
IEEE Symposium on Security and Privacy (S&P), May 2013.
[68] J. Poon and V. Buterin. Plasma: Scalable autonomous smart
contracts, 2017. https://plasma.io/plasma.pdf.

[69] J. Poon and T. Dryja. The Bitcoin Lightning Network:

Scalable off-chain instant payments. https:
//lightning.network/lightning-network-paper.pdf,
2016.

[70] C. Reitwiessner. zkSNARKs test code.

https://gist.github.com/chriseth/
f9be9d9391efc5beb9704255a8e2989d, 2017.

[71] F. B. Schneider. Implementing fault-tolerant services using

the state machine approach: A tutorial. ACM Computing
Surveys, 22(4):299–319, Dec. 1990.

[72] S. Setty. Spartan: Efﬁcient and general-purpose zkSNARKs

without trusted setup. Cryptology ePrint Archive, Report
2019/550, 2019.

[73] S. Setty, S. Angel, T. Gupta, and J. Lee. Proving the correct
execution of concurrent services in zero-knowledge. In
Proceedings of the USENIX Symposium on Operating Systems
Design and Implementation (OSDI), 2018.

[74] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and

M. Walﬁsh. Resolving the conﬂict between generality and
plausibility in veriﬁed computation. In Proceedings of the
ACM European Conference on Computer Systems (EuroSys),
Apr. 2013.

[75] S. Setty, R. McPherson, A. J. Blumberg, and M. Walﬁsh.

Making argument systems for outsourced computation
practical (sometimes). In Proceedings of the Network and
Distributed System Security Symposium (NDSS), Feb. 2012.
[76] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and
M. Walﬁsh. Taking proof-based veriﬁed computation a few
steps closer to practicality. In Proceedings of the USENIX
Security Symposium, Aug. 2012.

[77] Y. Sompolinsky and A. Zohar. Secure high-rate transaction

processing in Bitcoin. In Proceedings of the International
Financial Cryptography and Data Security Conference, pages
507–527, 2015.

[78] J. Teutsch and C. Reitwießner. A scalable veriﬁcation solution

for blockchains, Nov. 2017.
https://people.cs.uchicago.edu/teutsch/papers/
truebit.pdf.

[79] F. Vogelsteller and V. Buterin. EIP 20: ERC-20 token standard.

https://eips.ethereum.org/EIPS/eip-20, Nov. 2015.

[80] R. S. Wahby, Y. Ji, A. J. Blumberg, abhi shelat, J. Thaler,

M. Walﬁsh, and T. Wies. Full accounting for veriﬁable
outsourcing. In Proceedings of the ACM Conference on
Computer and Communications Security (CCS), 2017.
[81] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walﬁsh.
Efﬁcient RAM and control ﬂow in veriﬁable outsourced
computation. In Proceedings of the Network and Distributed
System Security Symposium (NDSS), 2015.

[82] R. S. Wahby, I. Tzialla, abhi shelat, J. Thaler, and M. Walﬁsh.
Doubly-efﬁcient zkSNARKs without trusted setup. In
Proceedings of the IEEE Symposium on Security and Privacy

